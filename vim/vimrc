" {{{ || variables || ---
" filereadable() does not expand ~ (tilde) to home directory.
" Workaround is to use $HOME or expand()
let s:vimdir = expand("~/.vim")
" --- || variables || }}}

" {{{ || plugin || ---
if has('nvim')
	packadd cfilter
endif
" Loadng plugins must be before keymapping or they will override my keymappings!
let s:plugin_dir = s:vimdir . '/bundle'
let s:vim_plug_file = s:plugin_dir . '/vim-plug/plug.vim'
if filereadable(s:vim_plug_file)
	execute 'source ' . s:vim_plug_file
	call plug#begin(s:plugin_dir)
	Plug 'junegunn/vim-plug'
	" git
	Plug 'tpope/vim-fugitive'
	Plug 'airblade/vim-gitgutter'
	Plug 'zivyangll/git-blame.vim'
	" look & feel
	Plug 'vim-airline/vim-airline'
	Plug 'vim-airline/vim-airline-themes'
	" finder (path/dir/file/buffer/tac/etc.)
	Plug 'preservim/nerdtree'
	if executable('ranger')
		Plug 'francoiscabrol/ranger.vim'
		Plug 'rbgrouleff/bclose.vim' " ranger.vim depends on it
	endif
	Plug 'dbakker/vim-projectroot'
	Plug 'preservim/tagbar'
	Plug 'ctrlpvim/ctrlp.vim'		" required by vim-go GoDecls
	Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
	Plug 'junegunn/fzf.vim'
	Plug 'tpope/vim-projectionist'
	Plug 'c-brenn/fuzzy-projectionist.vim'
	" moving around
	Plug 'easymotion/vim-easymotion'
	Plug 'michaeljsmith/vim-indent-object'
	Plug 'bkad/CamelCaseMotion'
	" editting
	Plug 'bfredl/nvim-miniyank'
	Plug 'editorconfig/editorconfig-vim'
	Plug 'Yggdroot/indentLine'
	Plug 'preservim/nerdcommenter'
	Plug 'arthurxavierx/vim-caser'
	Plug 'tpope/vim-surround'
	Plug 'jiangmiao/auto-pairs'
	Plug 'AndrewRadev/splitjoin.vim'
	Plug 'tpope/vim-repeat'
	Plug 'junegunn/vim-easy-align'
	Plug 'neomake/neomake'
	if has('nvim') " no completion for conventional vim as it takes so long to start up
		Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
	endif
	Plug 'Shougo/echodoc.vim'
	Plug 'autozimu/LanguageClient-neovim', {
				\ 'branch': 'next',
				\ 'do': has('win32') ? 'powershell install.ps1' : 'bash install.sh',
				\ }
	" Plug 'SirVer/ultisnips'
	Plug 'honza/vim-snippets'
	Plug 'Shougo/neosnippet.vim'
	Plug 'Shougo/neosnippet-snippets'
	Plug 'vim-utils/vim-husk'
	" misc
	Plug 'sheerun/vim-polyglot'
	Plug 'tpope/vim-abolish'
	Plug 'vim-test/vim-test'
	Plug 'tmux-plugins/vim-tmux-focus-events'
	Plug 'tyru/open-browser.vim'

	" Language specific
	" <fish>
	Plug 'dag/vim-fish'
	" <js>
	Plug 'moll/vim-node'
	" <go>
	Plug 'fatih/vim-go', { 'tag': '*' } " Do not run `GoUpdateBinaries` post-hook as it takes a long time
	" <java>
	if executable('java')
		Plug 'artur-shaik/vim-javacomplete2' " complains if there is no java executable
	endif
	" <php>
	if executable('composer')
		Plug 'phpactor/phpactor', {'branch': 'master', 'do': 'composer install --no-dev -o'}
	endif
	Plug 'vim-php/tagbar-phpctags.vim'
	" Plug 'stephpy/vim-php-cs-fixer'
	Plug 'aeke/vim-php-cs-fixer' " Use this fork as the original has a bug
	Plug 'noahfrederick/vim-laravel'
	" <markdown>
	Plug 'iamcco/markdown-preview.nvim', { 'do': { -> mkdp#util#install() }}
	Plug 'mzlogin/vim-markdown-toc'
	Plug 'dhruvasagar/vim-table-mode'
	" <plantuml>
	Plug 'weirongxu/plantuml-previewer.vim'
	call plug#end()
else
	" these are called by plug#end()
	filetype plugin indent on
	syntax enable
endif
" --- || plugin || }}}

" {{{ || options || ---

" << system >>
set nocompatible						" do not use legacy mode
set encoding=utf-8
set fileencodings^=utf-8
if has('unix')
	set shell=/bin/bash
endif

" << looks and feel >>
set background=dark						" color scheme for dark background
if v:version >= 800						" suppress bell sound and flushing
	set belloff=all
else
	set visualbell t_vb=
endif
set t_Co=256							" enrich color
set number relativenumber				" show line number and distance relative to current line
if !&diff && (has('gui') || has('unix') || has('nvim'))
	set cursorline						" current line is underlined
endif
set nomodeline							" modeline brings security issue?
set nowrap								" line does not wrap
set scrolloff=5	sidescrolloff=1			" offset between cursor and the edge of window"
set sidescroll=1						" scroll minimal when cursor goes off the screen horizontally
if has('gui')
	set title
endif
set titlestring=%{getcwd()}				" current directory
set titlestring+=\ \|\ %F%a				" full path to the file and argument list info
if !empty(v:servername)
	set titlestring+=\ \|\ %{v:servername}	" server name such as 'VIM'
endif
set laststatus=2						" always display status bar
set showtabline=2						" always display tabline
set shortmess+=c

" {{{ || Compose tabline || ---
function! MyTabLine()
	let l:max_fname_length = 20
	let l:tabline = ''
	for l:cnt in range(tabpagenr('$'))
		let l:tabpagecnt = l:cnt + 1

		" select the highlighting
		if l:tabpagecnt == tabpagenr()
			let l:tabline .= '%#TabLineSel#'
		else
			let l:tabline .= '%#TabLine#'
		endif

		" compose tabline
		let l:tabline .= ' '
		" Add '+' if one of the buffers in the tab page is modified
		let l:buflist = tabpagebuflist(l:tabpagecnt)
		" Add '+' if one of the buffers in the tab page is modified
		for l:bufnr in l:buflist
			if getbufvar(l:bufnr, "&modified")
				let l:tabline .= '+'
				break
			endif
		endfor
		" Add tab number
		let l:tabline .= l:tabpagecnt
		" Add window number if more than 1 is opened
		let l:wincnt = tabpagewinnr(l:tabpagecnt, '$')
		if l:wincnt > 1
			let l:tabline .= ':' . l:wincnt
		endif
		let l:tabline .= ' '
		" Add file name
		let l:winnr = tabpagewinnr(l:tabpagecnt)
		let l:curbufnr = l:buflist[l:winnr - 1]
		let l:fname = bufname(l:curbufnr)
		let l:fnamelen = strlen(l:fname)
		if l:fnamelen == 0
			" TODO distinguish Location List and Quickfix List
			if getbufvar(l:curbufnr, "&filetype") ==# 'qf'
				let l:tabline .= '[Loc List]'
			else
				let l:tabline .= '[No Name]'
			endif
		else
			let l:modified_fname = fnamemodify(l:fname, ':t')
			let l:fnamelen = len(l:modified_fname)
			if l:fnamelen > l:max_fname_length
				let l:modified_fname = l:modified_fname[l:fnamelen-l:max_fname_length:]
			endif
			let l:tabline .= l:modified_fname
		endif
		let l:tabline .= ' '
	endfor

	" after the last tab fill with TabLineFill
	let l:tabline .= '%#TabLineFill#'

	return l:tabline
endfunction

set tabline=%!MyTabLine()
" --- || Compose tabline|| }}}

" reverse the color of unselected tab
highlight TabLine term=reverse cterm=bold,reverse gui=reverse

" << editing >>
set tabstop=4 noexpandtab shiftwidth=4	" change tab width
set autoindent smartindent				" indentation support
set shiftround							" round tab width for > and < command
set fileformats=unix,dos,mac			" Prefer Unix over Windows over OSX formats
set listchars=tab:\|\                   " Show unvisible chars
set backspace=indent,eol,start			" Enable backspace to wrap line and delete break
set virtualedit=block					" Allow cursor to move beyond the EOL when visual-block mode
set iminsert=0 imsearch=-1				" prevent entering Japaneve input mode when entering insert and search mode
set shellslash							" always use forward slash
set formatoptions+=jmM
set nofixendofline                      " Preserve the current EOL state
set ttimeoutlen=0						" This prevents <Esc> to hang in input mode on Linux terminal
if has('persistent_undo')
	if !isdirectory($HOME . '/.local/share/nvim/undo')
		call mkdir($HOME . '/.local/share/nvim/undo', 'p')
	endif
	set undofile						" enable undo beyond sessions
	set undodir=$HOME/.local/share/nvim/undo,.
endif

" << search >>
set ignorecase							" Do case insensitive matching
set smartcase							" Do smart case matching
set incsearch							" Incremental search
set hlsearch							" highlight the match
set matchpairs+=<:>						" % command jumps between <> as well

" << others >>
if !isdirectory($HOME . '/.local/share/nvim/swap')
	call mkdir($HOME . '/.local/share/nvim/swap', 'p')
endif
set directory=$HOME/.local/share/nvim/swap,.
set cpoptions+=Iy						" I:autoindent is not removed when moving to other lines
set whichwrap+=<,>						" allow <Left> and <Right> in move to other lines
set complete+=k							" ins-completion option (include dictionary search)
set completeopt=longest,menuone,preview	" ins-completion mothod (complete to longest, display menu even though only one match)
set splitbelow splitright				" splitted windows goes to below or right
set showcmd								" Show (partial) command in status line.
set lazyredraw							" screen will not be redrawn till macro execution is done
set tags=./tags;,./TAGS;,tags;,TAGS;
set diffopt+=vertical
set sessionoptions=blank,curdir,folds,tabpages,winsize

" << command mode >>
set history=1000
set wildignorecase						" command mode completion ignores case
set wildignore+=*.swp,*.bak,*.class		" ignore files this specified extentions on completion
set wildmenu							" display menu on command line completion
" neosnippet behaves strangely if 'wildcharm' is set to <Tab>, so use another key to workaround
" set wildcharm=<Tab>						" This enables cycling through popup version of wildmenu with <expr> keymap
set wildcharm=<F10>
set wildmode=full,longest:full			" command mode completion method
" --- || options || }}}

" {{{ || highlight || ---
highlight Pmenu ctermfg=254 ctermbg=22 gui=bold guibg=Blue
highlight ColorColumn ctermbg=6 guibg=DarkCyan
" --- || highlight || }}}

" {{{ || automatically enter paste mode when pasting || ---
if &term =~ "xterm"
	let &t_ti .= "\e[?2004h"
	let &t_te .= "\e[?2004l"
	let &pastetoggle="\e[201~"

	function! XTermPasteBegin(command)
		set paste
		return a:command
	endfunction

	nnoremap <special> <expr> <Esc>[200~ XTermPasteBegin("i")
	" This delays exiting Insert and Command mode by pressing <Esc>
	" inoremap <special> <expr> <Esc>[200~ XTermPasteBegin("")
	" cnoremap <special> <Esc>[200~ <Nop>
	" cnoremap <special> <Esc>[201~ <Nop>
endif
" --- || automatically enter paste mode when pasting || }}}

" {{{ || enable meta-key bindings || ---
if !get(s:, 'meta_key_bound') && has('unix') && !has('nvim')
	" fix meta-keys which generate <Esc>a .. <Esc>z
	" do this once only so that keymaps defined by plugin will not be overwritten with <Nop>
	let s:set_meta_to_esc = "set <M-%s>=\e%s"
	let s:map_esc_to_meta = "noremap%s \e%s <M-%s>"
	let s:map_meta_to_nop = "noremap%s <M-%s> <Nop>"
	let c = 'a'
	while c <= 'z'
		" lower case
		exec printf(s:set_meta_to_esc, c, c)
		exec printf(s:map_esc_to_meta, '!', c, c)
		exec printf(s:map_esc_to_meta, '', c, c)
		exec printf(s:map_meta_to_nop, '!', c)
		exec printf(s:map_meta_to_nop, '', c)
		" upper case - skip M-O as it is part of del key, ins key, F key and etc
		if c != 'o'
			let C = toupper(c)
			exec printf(s:set_meta_to_esc, C, C)
			exec printf(s:map_esc_to_meta, '!', C, C)
			exec printf(s:map_esc_to_meta, '', C, C)
			exec printf(s:map_meta_to_nop, '!', C)
			exec printf(s:map_meta_to_nop, '', C)
		endif
		let c = nr2char(1+char2nr(c))
	endwhile
	unlet c C

	" meta + special-keys
	" note: '[' cannot be mapped as it's part of some keycodes
	exec "set <M-$>=\e$"
	exec "set <M-#>=\e#"
	exec "set <M-*>=\e*"
	exec "set <M-+>=\e+"
	exec "set <M-->=\e-"
	exec "set <M-/>=\e/"
	exec "set <M-:>=\e:"
	exec "set <M-;>=\e;"
	exec "set <M-=>=\e="
	" exec "set <M-]>=\e]" " This causes vim to work funny
	exec "set <M-_>=\e_"
	exec "set <M-`>=\e`"

	for n in range(0, 9)
		exec "set <M-".n.">=\e".n
		exec "noremap! \e".n." <M-".n.">"
		exec "noremap \e".n." <M-".n.">"
		exec "noremap <M-".n."> <Nop>"
	endfor
	unlet n
endif
let s:meta_key_bound = 1
" --- || enable meta-key bindings || }}}

" {{{ || autocmd || ---
" augroup prevents duplicated effect by disabling previous effect of the same group
if has("autocmd")
	augroup buffer_init
		autocmd!
		" jump to the last position when reopening a file
		autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
	augroup END

	" hightlight for unwanted spaces
	augroup highlighter
		autocmd!
		" highlight trailing whitespaces and mixed whitespaces except for help files
		" VimEnter does not do the job somehow
		if has('nvim')
			" SpellRare (under curl) does not work on nvim
			autocmd BufWinEnter,InsertEnter,InsertLeave * match Visual /\s\+$\| \+\t\+\|\t\+ \+/
		else
			autocmd BufWinEnter,InsertEnter,InsertLeave * match SpellRare /\s\+$\| \+\t\+\|\t\+ \+/
		endif
		autocmd FileType help silent! call matchdelete(1)
	augroup END

	function! s:PreviousTabStoreState()
		let s:tab_current = tabpagenr()
		let s:tab_last = tabpagenr('$')
	endfunction
	function! s:PreviousTabTabClosed()
		if s:tab_current > 1 && s:tab_current < s:tab_last
			exec 'tabp'
		endif
	endfunction
	augroup prev_tab
		autocmd!
		autocmd TabEnter,TabLeave * call s:PreviousTabStoreState()
		autocmd TabClosed * call s:PreviousTabTabClosed()
	augroup end

	augroup misc
		autocmd!
		" fix windows size on resizing vim
		autocmd VimResized * :wincmd =
		" disable relativenumber in quickfix window
		autocmd FileType qf setlocal norelativenumber
		" if has('nvim')
			" automatically enter terminal-mode
			" XXX this causes GoRun to enter insert mode
			" autocmd TermOpen * startinsert
		" endif
		" paired with completeopt=preview
		autocmd CompleteDone * pclose
	augroup END
endif
" --- || autocmd || }}}

" {{{ || key mapping || ---

" {{{ || Leader || ---
noremap <Space> <Nop>
let mapleader = "\<Space>"
nnoremap <Leader> "z
vnoremap <Leader> "z

noremap <C-Space> <Nop>
noremap! <C-Space> <Nop>
" Use local leader for ftplugins
let maplocalleader = "\<C-Space>"
nnoremap <LocalLeader> "Z
vnoremap <LocalLeader> "Z

map ; [Chief]
if has('xterm_clipboard')
	nnoremap [Chief] "+
	vnoremap [Chief] "+
else
	nnoremap [Chief] "*
	vnoremap [Chief] "*
endif

map , [Captain]
nnoremap [Captain] "_
vnoremap [Captain] "_
" --- || Leader || }}}

" {{{ || cursor motion || ---
noremap j gj
noremap k gk
noremap <expr> <silent> <Home> col('.') == match(getline('.'),'\S')+1 ? '0' : '^'
map H <Home>
nnoremap L $
onoremap L $
vnoremap L g_
" J & K below is to prevent accidental line join and opening help
vnoremap J j
vnoremap K k

" {{{ || insert/command mode || ---
inoremap <C-b> <Left>
inoremap <C-f> <Right>
inoremap <M-f> <C-Right>
inoremap <M-b> <C-Left>
imap <silent> <Home> <C-o><Home>
imap <C-a> <Home>
inoremap <expr> <C-e> pumvisible() ? "\<C-e>" : "\<End>"
inoremap <C-p> <Up>
inoremap <C-n> <Down>
" --- || insert/command mode || }}}

" [always search forward/backword]
" noremap <expr> <Bslash> getcharsearch().forward ? ';' : ','
" noremap <expr> <Bar> getcharsearch().forward ? ',' : ';'
vnoremap al ggoG$
" all
onoremap <silent> al :normal! VggoG<CR>
" line without indent
onoremap <silent> u :normal! ^v$h<CR>
" line including indent
onoremap <silent> U :normal! 0v$h<CR>
" XXX these do not work if the cursor is on the last element
" as in /cursor/is/he|re
onoremap <silent> ad :call SelectPair('${', '', '}', 1)<CR>
vnoremap <silent> ad :<C-u>call SelectPair('${', '', '}', 1)<CR>
onoremap <silent> ie :call SelectElement()<CR>
vnoremap <silent> ie :<C-u>call SelectElement()<CR>
vnoremap <silent> i, T,ot,
onoremap <silent> i, :normal! T,vt,<CR>
vnoremap <silent> a, T,of,
onoremap <silent> a, :normal! T,vf,<CR>
vnoremap <silent> i. T.ot.
onoremap <silent> i. :normal! T.vt.<CR>
vnoremap <silent> a. T.of.
onoremap <silent> a. :normal! T.vf.<CR>
vnoremap <silent> i/ T/ot/
onoremap <silent> i/ :normal! T/vt/<CR>
vnoremap <silent> a/ T/of/
onoremap <silent> a/ :normal! T/vf/<CR>
vnoremap <silent> iu T_ot_
onoremap <silent> iu :normal! T_vt_<CR>
vnoremap <silent> au T_of_
onoremap <silent> au :normal! T_vf_<CR>
nnoremap [Chief]v :call SetOperatorFunc('VisualOperator')<CR>g@
function! VisualOperator(operatortype)
	if a:operatortype ==# 'v'
		normal! `<v`>
	else
		normal! `[v`]
	endif
endfunction
" --- || cursor motion || }}}

" {{{ || scrolling || ---
noremap <C-u> 5<C-u>
noremap <C-d> 5<C-d>
noremap <M-y> zh
noremap <M-e> zl
noremap <M-Y> zH
noremap <M-E> zL
" --- || scrolling || }}}

" {{{ || tag || ---
nnoremap [t <C-t>
nnoremap ]t :tag<CR>
" --- || tag || }}}

" {{{ || editing || ---
nnoremap <M-x> "_x
nnoremap <M-X> "_X
nnoremap =p =']
vnoremap p "_c<C-r>"<Esc>
vnoremap P "_c<C-r>"<Esc>
" [insert/command mode]
inoremap <C-w> <C-g>u<C-w>
inoremap <C-u> <C-g>u<C-u>
cnoremap <expr> <C-q> Expander()
inoremap <expr> <C-y> pumvisible() ? "\<C-y>" : "<C-g>u\<C-r>\""
cnoremap <expr> <C-y> wildmenumode() ? "\<C-e>" : "\<C-r>\""
" cnoremap <expr> <Tab> wildmenumode() ? "\<C-n>" : "\<Tab>"
cnoremap <expr> <Tab> wildmenumode() ? "\<C-n>" : "\<F10>"
cnoremap <expr> <C-g> wildmenumode() ? "\<Down>" : "\<C-g>"
cnoremap <expr> <C-t> wildmenumode() ? "\<Up>" : "\<C-t>"
noremap! <M-y> <C-r>*
inoremap <C-d> <DEL>
inoremap <M-d> <C-g>u<C-\><C-o>"_dw
inoremap <C-k> <C-g>u<C-\><C-o>"_D
inoremap <M-h> <C-g>u<C-w>
cnoremap <M-h> <C-w>
inoremap <M-n> <C-e>
inoremap <M-p> <C-y>
inoremap <M-t> <C-d>
" [UPPER/lowercase & Capitalize]
inoremap <M-u> <Esc>gUiwea
inoremap <M-l> <Esc>guiwea
inoremap <M-c> <Esc>guiwgU<right>ea
" [Line break/join]
nnoremap <expr> <CR> &filetype == 'qf' ? "\<CR>" : "i\<CR>\<Esc>"
nnoremap <M-m> mpo<Esc>0Dg`p|	"insert blank line below
nnoremap <M-M> mpO<Esc>0Dg`p|	"insert blank line above
nnoremap <C-j> o<Esc>
nnoremap <M-j> O<Esc>
inoremap <C-j> <Esc>o
inoremap <M-j> <Esc>O
" [Other editing]
vnoremap y ygv<Esc>|	"place cursor after the selection when yanking
nnoremap Y y$
vnoremap <silent> <C-a> <C-a>gv
vnoremap <silent> <C-x> <C-x>gv
nnoremap <silent> g<C-a> :call search("[0-9]", 'be', line('.'))<CR><C-a>
nnoremap <silent> g<C-x> :call search("[0-9]", 'be', line('.'))<CR><C-x>
nnoremap d. /\s\+$<CR>"_dgn|	" delete trailing spaces
inoremap <silent> <M-,> <Cmd>call edit#base#Append(',')<CR>
nnoremap <silent> <M-,> <Cmd>call edit#base#Append(',')<CR>
vnoremap <silent> <M-,> :call edit#base#Append(',')<CR>
" [move line]
" nnoremap <silent> <expr> <M-j> ":\<C-u>silent! move .+".v:count1."\<CR>=="
" nnoremap <silent> <expr> <M-k> ":\<C-u>silent! move .-".(v:count1+1)."\<CR>=="
" ones for visual mode requires range ('<,'>) to work as intended
" vnoremap <silent> <expr> <M-j> ":\<C-u>silent! '<,'>move '>+".(v:count1)."\<CR>gv=gv"
" vnoremap <silent> <expr> <M-k> ":\<C-u>silent! '<,'>move '<-".(v:count1+1)."\<CR>gv=gv"
" [undo redo]
nnoremap U <Nop>
inoremap <C-_> <C-o>u
inoremap <C-/> <C-o>u
inoremap <M-/> <C-o><C-r>
" [set undo break before commands below]
inoremap <Space> <C-g>u<Space>
inoremap <C-m> <C-g>u<C-m>
inoremap . .<C-g>u
" --- || editing || }}}

" {{{ || register || ---
" used registers
" r: RedirCmdOutputToReg
" keymap for "z, "Z is defined in leader section
nnoremap "" <Cmd>registers<CR>
nnoremap <Leader><Space> <Cmd>call register#base#CopyRegisterToAnother('"', 'z')<CR>
if has('xterm_clipboard')
	nnoremap [Chief]; <Cmd>call register#base#CopyRegisterToAnother('"', '+')<CR>
elseif has('clipboard')
	nnoremap [Chief]; <Cmd>call register#base#CopyRegisterToAnother('"', '*')<CR>
endif
nnoremap <Leader>r <Cmd>call register#base#CopyRegisterToAnotherInteract()<CR>
nnoremap [Chief]r <Cmd>call register#base#EditRegister()<CR>
nnoremap [Captain]r <Cmd>call register#base#ClearCharRegisters()<CR>
nnoremap yp <Cmd>let @* = expand('%:p') \| echo expand('%:p') 'copied to clipboard'<CR>
" --- || register || }}}

" {{{ || Mark || ---
noremap ' `
noremap ` '
nnoremap <Leader>m :<C-u>marks<CR>
" --- || Mark || }}}

" {{{ || Completion || ---
inoremap <expr> <C-l> pumvisible() ? "\<C-n>" : "\<C-x>\<C-n>"
inoremap <expr> <C-i> pumvisible() ? "\<C-n>" : "\<C-x>\<C-o>"
" --- || Completion || }}}

" {{{ || Search || ---
" AnnoyingSpaces: trailing white spaces or mixture of space and tab
let g:AnnoyingSpaces = "\\s\\+$\\| \\+\\t\\+\\|\\t\\+ \\+"
" open fold which the match belongs to so that you can view where exactly the
" match is.
nnoremap n nzx
nnoremap N Nzx
nnoremap <silent> [Captain]/ :let @/ = ''<CR>
" TODO change these to use function like QuickGrep
nnoremap <silent> * :let @/="\\V<C-r><C-w>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
nnoremap <silent> g* :let @/="\\<<C-r><C-w>\\>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
nnoremap <silent> <M-*> :let @/="\\V\\C<C-r><C-w>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
nnoremap <silent> g<M-*> :let @/="\\C\\<<C-r><C-w>\\>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
nnoremap <silent> <Leader>* :let @/="\\V<C-r>=escape(expand("<cWORD>"), "/\"")<CR>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
vnoremap <silent> * y:let @/="\\V<C-r>=escape(@@, "/\"")<CR>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
vnoremap <silent> g* y:let @/="\\V\\<<C-r>=escape(@@, "/\"")<CR>\\>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
nnoremap <C-g> /<C-r><C-w>
xnoremap <C-g> y/<C-r>"
nnoremap g<C-g> /\<Lt><C-r><C-w>\>
xnoremap g<C-g> y\<Lt>/<C-r>"\>
" [toggle highlight]
if exists('v:hlsearch')
	nnoremap <silent> <expr> <M-u> (&hlsearch && v:hlsearch ? ':nohlsearch<CR>' : ':set hlsearch<CR>')
else
	nnoremap <silent> <M-u> :set hlsearch! hlsearch?<CR>
endif
" --- || Search || }}}

" {{{ || Grep || ---
" COMBAK make it like QuickSubstitute() and take dictionary arguments?
" Lets you run lvimgrep quickly and open quickfix window
" @pattern string to grep
" @modify when non-zero, let the user modify the argument for vimgrep
function! QuickGrep(pattern, modify)
	let l:vimgrep_cmd = 'lvimgrep '
	let l:grep_arg = printf('/\V%s/gj %%', a:pattern)

	if a:modify
		let l:cursor_adjustment = repeat("\<Left>", 5)
		let l:grep_arg = Input(v:true, ':' . l:vimgrep_cmd, l:grep_arg . l:cursor_adjustment)
		if l:grep_arg is 0
			return
		endif
	endif

	call histadd(':', l:vimgrep_cmd . l:grep_arg)
	try
		silent execute l:vimgrep_cmd . l:grep_arg
	catch /^Vim\%((\a\+)\)\=:E480/	" catch error E480 - No match found
		redraw
		echohl ErrorMsg | echomsg v:exception | echohl NONE
		silent lclose
		return
	endtry

	call qf#base#QFOpenSmart(g:qf#base#qf_mode_location, v:false, 0)
endfunction
nnoremap <silent> [Captain]+  <Cmd>call QuickGrep('', 1)<CR>
nnoremap <silent> +           <Cmd>call QuickGrep(expand("<cword>"), 0)<CR>
nnoremap <silent> g+          <Cmd>call QuickGrep('\<'.expand("<cword>").'\>', 0)<CR>
nnoremap <silent> <Leader>+   <Cmd>call QuickGrep(expand("<cWORD>"), 0)<CR>
vnoremap <silent> +          y<Cmd>call QuickGrep(@@, 0)<CR>
vnoremap <silent> g+         y<Cmd>call QuickGrep('\<'.@@.'\>', 0)<CR>
" --- || Grep || }}}

" {{{ || Replace || ---
" Lets you run substitute quickly
" @pattern string to find
" @options available options are:
"			range:		same as [range] command parameter.
"			selection:	none-zero means search area is only within selection
"			case:		none-zero means case sensitive
"			exclusive:	none-zero means pattern will be wrapped with \< \>
function! QuickSubstitute(core_pattern, options)
	let l:opt_key_range = 'range'
	let l:opt_key_case = 'case'
	let l:opt_key_exclusive = 'exclusive'
	let l:opt_key_selection = 'selection'
	let l:base_substitute_cmd = '%ssubstitute/%s\V//gc'

	let l:range = has_key(a:options, l:opt_key_range) ? a:options[l:opt_key_range] : ''

	let l:search_pattern = ''
	if has_key(a:options, l:opt_key_selection)
		let l:search_pattern .= a:options[l:opt_key_selection] ? '\%V' : ''
	endif
	if has_key(a:options, l:opt_key_case)
		let l:search_pattern .= a:options[l:opt_key_case] ? '\C' : ''
	endif
	" check for exclusive should be the last so that pattern string comes after ordinary atoms
	if has_key(a:options, l:opt_key_exclusive) && a:options[l:opt_key_exclusive] == 1
		let l:search_pattern .= '\<' . a:core_pattern . '\>'
	else
		let l:search_pattern .= a:core_pattern
	endif

	let l:substitute_cmd = printf(l:base_substitute_cmd, l:range, l:search_pattern)

	let l:cursor_adjustment = repeat("\<Left>", a:core_pattern is '' ? 4 : 3)
	let l:substitute_cmd = Input(v:true, ':', l:substitute_cmd . l:cursor_adjustment)
	if l:substitute_cmd is 0
		return
	endif

	call histadd(':', l:substitute_cmd)
	try
		execute l:substitute_cmd
	catch /^Vim\%((\a\+)\)\=:E486/	" catch error E486 - No match found
		redraw
		echohl ErrorMsg | echomsg v:exception | echohl NONE
	endtry
endfunction
nnoremap [Captain]s  <Cmd>call QuickSubstitute('', {'range': '%'})<CR>
nnoremap [Captain]S  <Cmd>call QuickSubstitute('', {})<CR>
nnoremap <Leader>s   <Cmd>call QuickSubstitute(expand("<cword>"), {'range': '%'})<CR>
nnoremap <Leader>S   <Cmd>call QuickSubstitute(expand("<cword>"), {'range': '%', 'case': 1})<CR>
nnoremap [Chief]s    <Cmd>call QuickSubstitute(expand("<cword>"), {'range': '%', 'exclusive': 1})<CR>
nnoremap [Chief]S    <Cmd>call QuickSubstitute(expand("<cword>"), {'range': '%', 'exclusive': 1, 'case': 1})<CR>
vnoremap [Captain]s  <Cmd>call QuickSubstitute('', {'range': '%', 'selection': 1})<CR>
vnoremap [Captain]S  <Cmd>call QuickSubstitute(@@, {'range': '%', 'selection': 1})<CR>
vnoremap <Leader>s  y<Cmd>call QuickSubstitute(@@, {'range': '%'})<CR>
vnoremap <Leader>S  y<Cmd>call QuickSubstitute(@@, {'range': '%', 'case': 1})<CR>
vnoremap [Chief]s   y<Cmd>call QuickSubstitute(@@, {'range': '%', 'exclusive': 1})<CR>
vnoremap [Chief]S   y<Cmd>call QuickSubstitute(@@, {'range': '%', 'exclusive': 1, 'case': 1})<CR>
" --- || Replace || }}}

" {{{ || Quickfix/Location || ---
nnoremap <silent> <C-q> <Cmd>call qf#base#QuickfixCmd(v:count)<CR>
" --- || Quickfix/Location || }}}

" {{{ || Buffer || ---
command! BufOnly %bdelete | edit#
" --- || Buffer || }}}

" {{{ || Window || ---
nnoremap <silent> <C-w>O :only!<CR>
nnoremap <C-w>B :bdelete<CR>
" --- || Window || }}}

" {{{ || Tab || ---
noremap <C-t> <Nop>
nnoremap <silent> <expr> <C-t><C-n> ":\<C-u>".(v:count ? v:count : "")."tabnew\<CR>"
nnoremap <silent> <expr> <C-t><C-o> ":\<C-u>".(v:count ? v:count : "")."tabonly\<CR>"
nnoremap <silent> <expr> <C-t><C-q> ":\<C-u>".(v:count ? v:count : "")."tabclose\<CR>"
nnoremap <silent> <expr> <C-t><C-d> ":\<C-u>".(v:count ? v:count : "")."tab split\<CR>"
nnoremap <silent> <C-t><CR> <C-w><CR><C-w>T
nnoremap <C-t><C-f> <C-w>gf
nnoremap <C-l> gt
nnoremap <C-h> gT
nnoremap <silent> <expr> <M-l> ":\<C-u>silent! tabmove+".v:count1."<CR>"
nnoremap <silent> <expr> <M-h> ":\<C-u>silent! tabmove-".v:count1."<CR>"
for n in range(1, 9)
	execute printf("nnoremap <M-%s> %sgt", n, n)
endfor
unlet n
nnoremap <M-0> 10gt
" jump to last active tab
if has('autocmd')
	let g:lasttabnum = 1
	augroup last_tab
		autocmd!
		autocmd TabLeave * let g:lasttabnum = tabpagenr()
	augroup END
	nnoremap <silent> <C-t><C-t> :execute "tabnext " . g:lasttabnum<CR>
endif
" --- || Tab || }}}

" {{{ || Suspend/Close/Exit || ---
nnoremap ZB :bdelete!<CR>
nnoremap ZT :windo quit!<CR>
nnoremap <C-w><C-a> :windo confirm quit<CR>
nnoremap <C-w>A :confirm qall<CR>
" --- || Suspend/Close/Exit || }}}

" {{{ || Terminal || ---
tnoremap <C-\><C-\> <C-\><C-n>
if &shell =~ 'cmd'
	tnoremap <C-p> <Up>
	tnoremap <C-n> <Down>
	tnoremap <C-f> <Right>
	tnoremap <C-b> <Left>
	tnoremap <M-f> <C-Right>
	tnoremap <M-b> <C-Left>
	tnoremap <C-a> <Home>
	tnoremap <C-e> <End>
	tnoremap <C-d> <Del>
	tnoremap <C-u> <Esc>
endif

" --- || Terminal || }}}

" {{{ || Others || ---
map <S-Space> <Space>
nnoremap <C-s> :update<CR>
if has('gui')
	nnoremap <F3> :source $MYVIMRC<CR>:source $MYGVIMRC<CR>
else
	nnoremap <F3> :source $MYVIMRC<CR>
endif
nnoremap <Leader><F3> :tabnew $MYVIMRC<CR>
nnoremap [Chief]<F3> :call OpenFtplugins(&ft)<CR>
nnoremap [Captain]<F3> :SetFt<CR>
nnoremap Q gQ
nnoremap <M-c> <Cmd>mode<CR>
" [insert/command mode]
cnoremap <C-j> <Tab>
cnoremap <expr> <C-p> wildmenumode() ? "\<C-p>" : "\<Up>"
cnoremap <expr> <C-n> wildmenumode() ? "\<C-n>" : "\<Down>"
cnoremap <M-@> <Home>let @" = '<End>'
" retry triggering abbreviation
inoremap <C-g><C-]> <Esc>ciw<C-r>"<C-]>
" --- || Others || }}}

" --- || key mapping || }}}

" {{{ || plugin mapping and option || ---

" {{{ || vim-fugitive || ---
if exists('g:plugs["vim-fugitive"]')
	" let g:fugitive_no_maps = 1 " To prevent <C-n/p> to be mapped
	cnoreabbrev gs Git
	cnoreabbrev gl Git log
	cnoreabbrev glg vertical sbuffer <Bar> Gllog
	cnoreabbrev gd Gvdiffsplit
	cnoreabbrev gp Git push
	nnoremap <Leader>gs <Cmd>tab Git<CR>
	nnoremap <Leader>gl <Cmd>tab Git log<CR>
	nnoremap [Chief]gs <Cmd>vertical Git<CR>
	nnoremap [Chief]gl <Cmd>vertical Git log<CR>
endif
" --- || vim-fugitive || }}}

" {{{ || vim-gitgutter || ---
if exists('g:plugs["vim-gitgutter"]')
	let g:gitgutter_preview_win_floating = 0
	nnoremap [Captain]gg <Cmd>GitGutter<CR>
endif
" --- || vim-gitgutter || }}}

" {{{ || git-blame.vim || ---
if exists('g:plugs["git-blame.vim"]')
	nnoremap [Captain]gb <Cmd>GitBlame<CR>
endif
" --- || git-blame.vim || }}}

" {{{ || airline || ---
if !exists('g:plugs["vim-airline"]')
	set statusline=(%{winnr()})				" window number
	set statusline+=%f						" relative path
	set statusline+=[%{strlen(&fenc)?&fenc:'none'},%{&ff}]	" [file encoding,file format]
	set statusline+=%y%r%m					" file type; readonly flag; modified flag
	set statusline+=%=%c,%l/%L%6.6P			" right align; current column,line/total line; percentage with fixed width of 6 chars
endif
if exists('g:plugs["vim-airline"]')
	set noshowmode
	let g:airline_theme='cool'
	let g:airline_section_b = ''
	let g:airline_section_c = '(%{winnr()}) %<%{fnamemodify(getcwd(), ":~")} | %{expand("%")}%m %#__accent_red#%{airline#util#wrap(airline#parts#readonly(),0)}%#__restore__#'
endif
" --- || airline || }}}

" {{{ || nvim-miniyank || ---
if exists('g:plugs["nvim-miniyank"]')
	let g:miniyank_maxitems = 20
	map p <Plug>(miniyank-autoput)
	map P <Plug>(miniyank-autoPut)
	map <M-p> <Plug>(miniyank-cycle)
	map <M-P> <Plug>(miniyank-cycleback)
endif
" --- || nvim-miniyank || }}}

" {{{ || indentLine || ---
let g:indentLine_fileTypeExclude = ['markdown', 'json', 'nerdtree']
let g:indentLine_bufTypeExclude = ['help', 'terminal']
" --- || indentLine || }}}

" {{{ || NERDCommenter || ---
if exists('g:plugs["nerdcommenter"]')
	let g:NERDSpaceDelims = 1				" Add spaces after comment delimiters
	let g:NERDDefaultAlign = 'left'
	nnoremap <silent> <C-\> :call nerdcommenter#Comment("n","toggle")<CR>
	vnoremap <silent> <C-\> :call nerdcommenter#Comment("n","toggle")<CR>
	inoremap <silent> <C-\> <C-o>:call nerdcommenter#Comment("n","toggle")<CR>
endif
" --- || NERDCommenter || }}}

" {{{ || NERDTree || ---
if exists('g:plugs["nerdtree"]')
	let g:NERDTreeShowLineNumbers = 1
	let g:NERDTreeSortHiddenFirst = 1
	let g:NERDTreeShowHidden=1
	let g:NERDTreeQuitOnOpen=3
	let g:NERDTreeUseTCD=1
	let g:NERDTreeWinSize = 40
	let g:NERDTreeCustomOpenArgs={
				\ 'file': {'reuse': 'all', 'where': 't', 'keepopen': 1, 'stay': 1},
				\ 'dir': {'reuse': 'all', 'where': 't', 'keepopen': 1, 'stay': 1}
				\ }
	" call NERDTreeAddKeyMap({
	"     \ 'key': 'J',
	"     \ 'callback': {-> feedkeys('gt')},
	"     \ 'quickhelpText': 'use my own J mapping',
	"     \ 'scope': 'Node',
	"     \ 'override': 1})
	" call NERDTreeAddKeyMap({
	"     \ 'key': 'K',
	"     \ 'callback': {-> feedkeys('gt')},
	"     \ 'quickhelpText': 'use my own K mapping',
	"     \ 'scope': 'Node',
	"     \ 'override': 1})
	" NERDTreeAddKeyMap() overrides keybinds only with the same scope
	" (J/K are 'Node' scope)
	" So use autocmd to override no matter what scope default mapping is in
	" <buffer> is necessary to override
	" augroup nerd_tree
	"     autocmd!
	"     autocmd FileType nerdtree nnoremap <buffer> J gt
	"     autocmd FileType nerdtree nnoremap <buffer> K gT
	" augroup END
	function! s:InitNERDTreeCmds()
		let l:nerd_tree_cmds = {
					\ 'n': runcmds#init#MakeCmdInfo('NERDTree', v:false, [], v:true),
					\ 'N': runcmds#init#MakeCmdInfo('NERDTree %:h'),
					\ 't': runcmds#init#MakeCmdInfo('NERDTreeToggle'),
					\ 'o': runcmds#init#MakeCmdInfo('NERDTreeFocus'),
					\ 'v': runcmds#init#MakeCmdInfo('NERDTreeVCS'),
					\ 'b': runcmds#init#MakeCmdInfo('NERDTreeFromBookmark', v:false, [], v:true),
					\ 'f': runcmds#init#MakeCmdInfo('NERDTreeFind'),
					\ 'c': runcmds#init#MakeCmdInfo('NERDTreeCWD'),
					\ 'r': runcmds#init#MakeCmdInfo('NERDTreeRefreshRoot'),
					\ }
		function! s:NERDTreeCmds() closure
			return l:nerd_tree_cmds
		endfunction
	endfunction
	function! s:InitNERDTreeFlagDict()
		let l:nerd_tree_flags = runcmds#init#MakeFlagDict(';', "\<Space>")
		function! s:NERDTreeFlags() closure
			return l:nerd_tree_flags
		endfunction
	endfunction
	call s:InitNERDTreeCmds()
	call s:InitNERDTreeFlagDict()
	nnoremap <expr> [Chief]t runcmds#base#RunCmds("NERDTree", <SID>NERDTreeCmds(), <SID>NERDTreeFlags())
endif
" --- || NERDTree || }}}

" {{{ || ranger.vim || ---
if exists('g:plugs["ranger.vim"]')
	let g:NERDTreeHijackNetrw = 0 " this is NERDTree setting
	let g:ranger_map_keys = 0
	let g:ranger_replace_netrw = 1
	nnoremap [Chief]e <Cmd>tab split \| Ranger<CR>
endif
" --- || ranger.vim || }}}"

" {{{ || bclose.vim || ---
if exists('g:plugs["bclose.vim"]')
	let g:bclose_no_plugin_maps = v:true
endif
" --- || bclose.vim || }}}"

" {{{ || tagbar || ---
if exists('g:plugs["tagbar"]')
	" This is no longer working, though I do not see the support ended... (as of 2021-09-15)
	" let g:tagbar_type_go = {
	"             \ 'ctagstype' : 'go',
	"             \ 'kinds'     : [
	"                 \ 'p:package',
	"                 \ 'i:imports:1',
	"                 \ 'c:constants',
	"                 \ 'v:variables',
	"                 \ 't:types',
	"                 \ 'n:interfaces',
	"                 \ 'w:fields',
	"                 \ 'e:embedded',
	"                 \ 'm:methods',
	"                 \ 'r:constructor',
	"                 \ 'f:functions'
	"             \ ],
	"             \ 'sro' : '.',
	"             \ 'kind2scope' : {
	"                 \ 't' : 'ctype',
	"                 \ 'n' : 'ntype'
	"             \ },
	"             \ 'scope2kind' : {
	"                 \ 'ctype' : 't',
	"                 \ 'ntype' : 'n'
	"             \ },
	"             \ 'ctagsbin'  : 'gotags',
	"             \ 'ctagsargs' : '-sort -silent'
	"             \ }
	nnoremap <Leader>o :TagbarToggle<CR>
	nnoremap <Leader>O :TagbarOpen fj<CR>
endif
" --- || tagbar || }}}

" {{{ || vim-surround || ---
if exists('g:plugs["vim-surround"]')
	" set characters and correspondng wrappers
	" value for variable have to be surrounded by "", not ''
	" pre-defined mappings that are useful are:
	" t: "<[tag]>\r</[tag]>" <- [tag] will be replaced by user input
	" f: "[function](\r)" <- [function] will be replaced by user input
	let g:surround_no_mappings = 1
	nmap dr  <Plug>Dsurround
	nmap cr  <Plug>Csurround
	nmap cR  <Plug>CSurround
	nmap yr  <Plug>Ysurround
	nmap yR  <Plug>YSurround
	nmap yrr <Plug>Yssurround
	nmap yRR <Plug>YSsurround
	xmap R   <Plug>VSurround
	xmap gR  <Plug>VgSurround
	let g:surround_{char2nr('d')} = "${\r}"
	let g:surround_{char2nr('D')} = "\"${\r}\""
	let g:surround_{char2nr('s')} = "$(\r)"
	let g:surround_{char2nr('S')} = "\"$(\r)\""
endif
" --- || vim-surround || }}}

" {{{ || vim-projectroot || ---
if exists('g:plugs["vim-projectroot"]')
	cnoreabbrev pj <C-r>=ProjectRootGuess()<C-m>
endif
" --- || vim-projectroot || }}}

" {{{ || auto-pairs || ---
if exists('g:plugs["auto-pairs"]')
	let g:AutoPairsShortcutToggle = ''
	let g:AutoPairsShortcutFastWrap = '<M-w>'
	let g:AutoPairsShortcutJump = '<M-v>'
	let g:AutoPairsShortcutBackInsert = '<M-\>'
	let g:AutoPairsMapSpace = 0		" Enabling this maps <Space> to <C-]><C-R>=... and <C-]> is unwanted
	let g:AutoPairsMultilineClose = 0
	inoremap <silent> <Space> <C-g>u<C-r>=AutoPairsSpace()<CR>
endif
" --- || auto-pairs || }}}

" {{{ || easy-motion || ---
if exists('g:plugs["vim-easymotion"]')
	" this option unmap all easymotion-prefix including user defined ones
	" let g:EasyMotion_do_mapping = 0
	let g:EasyMotion_smartcase = 1
	let g:EasyMotion_use_upper = 1
	let g:EasyMotion_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ;'
	let g:EasyMotion_enter_jump_first = 1
	let g:EasyMotion_space_jump_first = 1
	let g:EasyMotion_off_screen_search = 1
	" this disables highlighting by `n` command, but you need easymotion-next/prev to move around
	let g:EasyMotion_add_search_history = 1
	let g:EasyMotion_startofline = 0
	" mapping easymotion-prefix prevents <Leader><Leader> from being mapped
	" map <S-F12> <Plug>(easymotion-prefix)
	map s <Plug>(easymotion-prefix)
	map f <Plug>(easymotion-fl)
	map F <Plug>(easymotion-Fl)
	map t <Plug>(easymotion-tl)
	map T <Plug>(easymotion-Tl)
	map s/ <Plug>(easymotion-sn)
	map s. <Plug>(easymotion-repeat)
	map <Bslash> <Plug>(easymotion-next)
	map <Bar> <Plug>(easymotion-prev)
endif
" --- || easy-motion || }}}

" {{{ || CamelCaseMotion || ---
if exists('g:plugs["CamelCaseMotion"]')
    map <silent> <M-w> <Plug>CamelCaseMotion_w
    map <silent> <M-b> <Plug>CamelCaseMotion_b
    omap <silent> im <Plug>CamelCaseMotion_ie
    xmap <silent> im <Plug>CamelCaseMotion_ie
    omap <silent> am <Plug>CamelCaseMotion_iw
    xmap <silent> am <Plug>CamelCaseMotion_iw
endif
" --- || CamelCaseMotion || }}}

" {{{ || fzf.vim || ---
if exists('g:plugs["fzf.vim"]')
	let g:fzf_command_prefix = 'Fzf'
    let g:fzf_buffers_jump = 1
	imap <c-x><c-k> <plug>(fzf-complete-word)
	imap <c-x><c-f> <plug>(fzf-complete-path)
	imap <c-x><c-l> <plug>(fzf-complete-line)

	function! s:InitFzfCmds()
		let l:fzf_cmds = {
					\ 'f': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Files'),
					\ 'F': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Files %:h'),
					\ 'g': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'GFiles'),
					\ 'G': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'GFiles?'),
					\ 'b': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Buffers'),
					\ 'r': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Rg', v:false, [], v:true),
					\ 'L': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Lines'),
					\ 'l': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'BLines'),
					\ 'T': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Tags'),
					\ 't': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'BTags'),
					\ 'k': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Marks'),
					\ 'w': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Windows'),
					\ 'y': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'History'),
					\ ':': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'History:'),
					\ '/': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'History/'),
					\ 's': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Snippets'),
					\ 'C': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Commits'),
					\ 'c': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'BCommits'),
					\ 'd': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Commands'),
					\ 'm': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Maps'),
					\ 'h': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Helptags'),
					\ }
		function! s:FzfCmds() closure
			return l:fzf_cmds
		endfunction
	endfunction
	function! s:InitFzfFlagDict()
		let l:fzf_flags = runcmds#init#MakeFlagDict(';', "\<Space>")
		function! s:FzfFlags() closure
			return l:fzf_flags
		endfunction
	endfunction
	call s:InitFzfCmds()
	call s:InitFzfFlagDict()
	nnoremap <expr> [Chief]f runcmds#base#RunCmds("FZF", <SID>FzfCmds(), <SID>FzfFlags())
endif
" --- || fzf.vim || }}}

" {{{ || ctrlp || ---
if exists('g:plugs["ctrlp.vim"]')
	" for now, just disable the default mapping to prevent from <C-p> to be overridden
	let g:ctrlp_map = '<F13>'
endif
" --- || ctrlp || }}}

" {{{ || vim-projectionist || ---
let g:projectionist_heuristics = {
			\   "src/main/java/|src/test/java/": {
			\     "src/main/java/*.java": {
			\       "alternate": "src/test/java/{}Test.java",
			\       "type": "main"
			\     },
			\     "src/test/java/*.java": {
			\       "alternate": "src/main/java/{}.java",
			\       "type": "test"
			\     },
			\     "src/main/resources/*": {
			\       "type": "resource"
			\     },
			\     "src/test/resources/*": {
			\       "type": "tresource"
			\     }
			\   }
			\ }
" --- || vim-projectionist || }}}

" {{{ || UltiSnips || ---
if exists('g:plugs["ultisnips"]')
	let g:UltiSnipsExpandTrigger="<C-]>"
	let g:UltiSnipsJumpForwardTrigger="<C-s>"
	let g:UltiSnipsJumpBackwardTrigger="<M-s>"
	cnoreabbrev us call UltiSnips#
endif
" --- || UltiSnips || }}}

" {{{ || neosnippet.vim || ---
if exists('g:plugs["neosnippet.vim"]')
	let g:neosnippet#enable_snipmate_compatibility = 1
	let g:neosnippet#snippets_directory = '~/toybox/vim/rtp/neoppets/'
	imap <C-]> <Plug>(neosnippet_expand_or_jump)
	smap <C-]> <Plug>(neosnippet_expand_or_jump)
	xmap <C-]> <Plug>(neosnippet_expand_target)
endif
" --- || neosnippet.vim || }}}

" {{{ || LanguageClient-neovim || ---
if exists('g:plugs["LanguageClient-neovim"]')
	set hidden
	let g:LanguageClient_changeThrottle = 0.5
	let g:LanguageClient_diagnosticsList = "Location"
	let g:LanguageClient_serverCommands = {
				\ 'go': [$GOPATH . '/bin/gopls'],
				\ 'java': [$HOME.'/toybox/vim/helper/java-lsp.sh', '-data', getcwd()],
				\ 'javascript': ['typescript-language-server', '--stdio'],
				\ 'php': [s:plugin_dir . '/phpactor/bin/phpactor', 'language-server'],
				\ 'python': [$HOME.'/.local/bin/pyls']
				\ }
	let g:LanguageClient_diagnosticsDisplay = {
				\ 1: {
				\     "name": "Error",
				\     "texthl": "ALEError",
				\     "signText": "E",
				\     "signTexthl": "Error",
				\     "virtualTexthl": "Error",
				\ },
				\ 2: {
				\     "name": "Warning",
				\     "texthl": "ALEWarning",
				\     "signText": "W",
				\     "signTexthl": "Search",
				\     "virtualTexthl": "Todo",
				\ },
				\ 3: {
				\     "name": "Information",
				\     "texthl": "ALEInfo",
				\     "signText": "I",
				\     "signTexthl": "Todo",
				\     "virtualTexthl": "Todo",
				\ },
				\ 4: {
				\     "name": "Hint",
				\     "texthl": "ALEInfo",
				\     "signText": "H",
				\     "signTexthl": "Todo",
				\     "virtualTexthl": "Todo",
				\ },
				\ }
	let g:LanguageClient_loggingFile = expand('~/.local/share/nvim/LanguageClient.log')
	let g:LanguageClient_serverStderr = expand('~/.local/share/nvim/LanguageServer.log')

	let s:def_cmds = {
				\ 'a': runcmds#init#MakeCmdInfo('AV'),
				\ 'A': runcmds#init#MakeCmdInfo('LcnCodeAction'),
				\ 'd': runcmds#init#MakeCmdInfo('LcnHover'),
				\ 'f': runcmds#init#MakeCmdInfo('LcnFormat'),
				\ 'h': runcmds#init#MakeCmdInfo('LcnDocHighlight'),
				\ 'H': runcmds#init#MakeCmdInfo('LcnDocHighlightClear'),
				\ 'n': runcmds#init#MakeCmdInfo('LcnRename'),
				\ 'o': runcmds#init#MakeCmdInfo('LcnDocSymbol'),
				\ 'R': runcmds#init#MakeCmdInfo('LcnReference'),
				\ }
	function! DefaultCmds()
		return copy(s:def_cmds)
	endfunction

	command! LcnCodeAction call LanguageClient#textDocument_codeAction()
	command! LcnFormat call LanguageClient#textDocument_formatting()
	command! LcnDocHighlight call LanguageClient#textDocument_documentHighlight()
	command! LcnDocHighlightClear call LanguageClient#clearDocumentHighlight()
	command! LcnDocSymbol call LanguageClient#textDocument_documentSymbol()
	command! LcnHover call LanguageClient#textDocument_hover()
	command! LcnRename call LanguageClient#textDocument_rename()
	command! LcnReference call LanguageClient#textDocument_references()

	nnoremap <C-]> <Cmd>call LanguageClient#textDocument_definition()<CR>
	nnoremap <C-w><C-]> <Cmd>split \| call LanguageClient#textDocument_definition()<CR>
	nnoremap [Chief]<C-]> <Cmd>vertical split \| call LanguageClient#textDocument_definition()<CR>
	nnoremap <C-t><C-]> <Cmd>tab split \| call LanguageClient#textDocument_definition()<CR>
	nnoremap g<C-]> <Cmd>call LanguageClient#textDocument_implementation()<CR>
	nnoremap <C-w><C-]> <Cmd>split \| call LanguageClient#textDocument_implementation()<CR>
	nnoremap [Chief]g<C-]> <Cmd>vertical split \| call LanguageClient#textDocument_implementation()<CR>
	nnoremap <C-t>g<C-]> <Cmd>tab split \| call LanguageClient#textDocument_implementation()<CR>
	inoremap <C-g><C-h> <Cmd>call LanguageClient#textDocument_signatureHelp()<CR>
endif
" --- || LanguageClient-neovim || }}}

" {{{ || neomake || ---
if exists('g:plugs["neomake"]')
	try
		call neomake#configure#automake('w')
	catch /^Vim\%((\a\+)\)\=:E117/
		" The function does not exist. Ignore it.
	endtry
	let g:neomake_open_list = 2
endif
" --- || neomake || }}}

" {{{ || deoplete || ---
if exists('g:plugs["deoplete.nvim"]')
	let g:deoplete#enable_at_startup = 1
	if has('win32')
		" cmd is "python.exe" so deoplete (yarp?) cannot find it by default
		let g:python3_host_prog="python"
	endif
	inoremap <silent> <expr> <C-i> pumvisible() ? "\<C-n>" : deoplete#manual_complete()
endif
" --- || deoplete || }}}

" {{{ || echodoc.vim || ---
let g:echodoc#enable_at_startup = 1
" floating breads UltiSnips' function to jump between markers
" let g:echodoc#type = 'floating'
" highlight link EchoDocFloat Pmenu
" --- || echodoc.vim || }}}

" {{{ || vim-abolish || ---
let g:abolish_no_mappings = 1
" --- || vim-abolish || }}}

" {{{ || vim-test || ---
if has('nvim')
	" By default, tab is opened left to the current tab, and that makes
	" closing the test tab focus the tab left to the original tab.
	" The below configuration opens the test right to the original tab.
	let test#neovim#term_position = "tab"
	let test#strategy = 'neovim'
endif
" --- || vim-test || }}}

" {{{ || vim-laravel || ---
if exists('g:plugs["vim-laravel"]')
	augroup init_laravel
	autocmd!
	autocmd User ProjectionistDetect
			\ if exists('b:laravel_root') |
			\   call projectionist#append(b:laravel_root, {
			\     'storage/logs/*.log': { 'type': 'log' },
			\     'storage/logs/laravel.log': { 'type': 'log' },
			\     'app/Http/Controllers/*.php': {
			\         'alternate': 'tests/Unit/Controllers/{}Test.php',
			\     },
			\     'app/Models/*.php': {
			\         'alternate': 'tests/Unit/Models/{}Test.php',
			\     }
			\   }) |
			\ endif
	augroup END
endif
" --- || deoplete || }}}

" --- || plugin mapping and option || }}}

" {{{ || abbreviation || ---
cnoreabbrev ehco echo
cnoreabbrev tn tabnew
cnoreabbrev tm TabnewMulti
cnoreabbrev tnro tabnew <Bar> view
cnoreabbrev spro split <Bar> view
cnoreabbrev vsro vsplit <Bar> view
cnoreabbrev ts tab split
cnoreabbrev vb vertical sbuffer
cnoreabbrev tb tab sbuffer
cnoreabbrev vh vertical help <Bar> execute "normal! \<lt>C-w>80\<Bar>"<C-Left><C-Left><C-Left><C-Left><Left>
cnoreabbrev th tab help
cnoreabbrev bold browse oldfiles
cnoreabbrev st new <Bar> terminal
cnoreabbrev vt vnew <Bar> terminal
cnoreabbrev tt tabnew <Bar> terminal
" --- || abbreviation || }}}

command! -complete=shellcmd -nargs=+ OutputShellCmdToQF call shell#base#ShellCmdToQF(<q-args>, v:false)
command! -complete=shellcmd -nargs=+ AppendShellCmdToQF call shell#base#ShellCmdToQF(<q-args>, v:true)
command! -complete=shellcmd -nargs=+ OutputShellCmdToPreview call shell#base#ShellCmdToPreview(<q-args>, v:false)
command! -complete=shellcmd -nargs=+ AppendShellCmdToPreview call shell#base#ShellCmdToPreview(<q-args>, v:true)

" {{{ || functions || ---
" move back cursor before a command is executed
" offset moves down and right n lines/columns to the original position
function! Preserve(command, linoff, coloff)
	let l = line(".") + a:linoff
	let c = col(".") + a:coloff
	echo a:command
	execute a:command
	call cursor(l, c)
endfunction

fun s:RedrawCancel()
	mode
	echo 'Cancelled'
	return 0
endf

" getchar() with Ctrl+C to cancel
" This returns numeric 0 if interrupted, so the value is compared using 'is'
function! GetChar(escape_means_cancel)
	try
		call inputsave()
		let l:char = nr2char(getchar())
		if a:escape_means_cancel && l:char == "\<Esc>"
			return s:RedrawCancel()
		endif
		return l:char
	catch /^Vim:Interrupt$/
		return s:RedrawCancel()
	finally
		call inputrestore()
	endtry
endfunction

" input() with Ctrl+C to cancel
" This returns numeric 0 if interrupted, so the value is compared using 'is'
function! Input(empty_means_cancel, ...)
	let l:opts = {}
	if a:0 > 0
		if type(a:1) == v:t_dict
			let l:opts = a:1
		else
			let l:opts['prompt'] = get(a:000, 0, '')
			let l:opts['default'] = get(a:000, 1, '')
			if a:0 >= 3
				let l:opts['completion'] = a:3
			endif
		endif
	endif
	try
		call inputsave()
		let l:input = input(l:opts)
		if a:empty_means_cancel && l:input is ''
			return s:RedrawCancel()
		endif
		return l:input
	catch /^Vim:Interrupt$/
		return s:RedrawCancel()
	finally
		call inputrestore()
	endtry
endfunction

" add elements only if the specified list does not contain the same value
function! AddUniq(list, elm)
	if index(a:list, a:elm) == -1
		call add(a:list, a:elm)
	endif
endfunction

function! IsCtrlAlpha(char)
	let l:char_num = char2nr(a:char)
	return char2nr("\<C-a>") <= l:char_num && l:char_num <= char2nr("\<C-z>")
endfunction

" @case: 1 for lowercase, 2 for uppercase
function! ConvertCtrlCharToNormal(char, case)
	const [l:lowercase, l:uppercase] = [1, 2]
	const l:deltas = {
				\ l:lowercase: char2nr('a') - char2nr("\<C-a>"),
				\ l:uppercase: char2nr('A') - char2nr("\<C-a>"),
				\}

	let l:char_num = char2nr(a:char)
	if !IsCtrlAlpha(a:char)
		echoerr printf('Invalid argument: %s is not ctrl-{alphabet}', a:char)
		return
	endif

	let l:delta = get(l:deltas, a:case, '')
	if l:delta is ''
		echoerr printf('Invalid argument: case must be either %s', [l:lowercase, l:uppercase])
		return
	endif

	return nr2char(l:char_num + l:delta)
endfunction

function! Expander()
	echohl Identifier
	echo 'Ctrl+: [b]asename, [s]implename, [d]irname, [f]ullname, [p]wd'
	echohl NONE
	let l:char = nr2char(getchar())
	if l:char ==? "b" || l:char ==? "\<C-b>"
		let l:cmd = "\<C-r>=expand('%:t')\<CR>"
	elseif l:char ==? "s" || l:char ==? "\<C-s>"
		let l:cmd = "\<C-r>=expand('%:t:r')\<CR>"
	elseif l:char ==? "d" || l:char ==? "\<C-d>"
		let l:cmd = "\<C-r>=expand('%:p:h')\<CR>"
	elseif l:char ==? "f" || l:char ==? "\<C-f>"
		let l:cmd = "\<C-r>=expand('%:p')\<CR>"
	elseif l:char ==? "p" || l:char ==? "\<C-p>"
		let l:cmd = "\<C-r>=getcwd()\<CR>"
	else
		echohl WarningMsg | echo 'Not an available option: '.l:char | echohl NONE
		sleep 1
		" return space and backspace to clean up the msg in command line
		let l:cmd = "\<Space>\<BS>"
	endif

	return l:cmd
endfunction

function! SelectBtwCols(sln, spos, eln, epos)
	" NOTE: Use cursor() instead of '|' command
	" searchpairpos() reterns 'n' as in nth char rather than column number.
	" '|' goes to column number, so if the line is indented with tab, '|' misbehaves.
	" since tab is single character but takes up &shiftwidth columns
	" execute 'normal! '.l:spos.'|v'.l:epos.'|'
	silent execute printf("normal! :call cursor(%s, %s)\<CR>v:call cursor(%s, %s)\<CR>v`<", a:sln, a:spos, a:eln, a:epos)
endf

function! SelectCamelWord()
	let l:crntLine = line('.')
	let l:camelRegexp = '[A-Za-z][a-z]*'
	let [_, l:spos] = searchpos(l:camelRegexp, 'bc', l:crntLine)
	let [_, l:epos] = searchpos(l:camelRegexp, 'ce', l:crntLine)
	call SelectBtwCols(l:crntLine, l:spos, l:crntLine, l:epos)
endfunction

function! SelectPair(start, middle, end, include)
	" NOTE: searchpairpos works a little weird as illustrated below
	" With 'c' option, if the cursor is on the first char of 'start' string (with 'b' option, last char of 'end' string),
	" searchpairpos() cannot find the match.
	let [l:sln, l:spos] = searchpairpos(a:start, a:middle, a:end, 'bc')
	let [l:eln, l:epos] = searchpairpos(a:start, a:middle, a:end)
	if l:spos == 0 || l:epos == 0
		" no match was found
		return
	endif
	if !a:include
		let l:spos = l:spos + len(a:start)
		let l:epos = l:epos - len(a:end)
	endif
	call SelectBtwCols(l:sln, l:spos, l:eln, l:epos)
endfunction

" Select either function/method call, object property, or struct (including object itself)
function! SelectElement()
	let l:elemRegexp = '[A-Za-z0-9_.]\+[({]'
	let [l:sln, l:spos] = searchpos(l:elemRegexp, 'bc')
	let [l:eln, l:epos] = searchpos(l:elemRegexp, 'e')
	let l:lastchar = getline(l:eln)[l:epos-1]
	if l:lastchar =~ '[({]'
		let l:start = l:lastchar
		let l:end = ')'
		if l:lastchar == '{'
			let l:end = '}'
		endif
		let [l:eln, l:epos] = searchpairpos(l:start, '', l:end)
	endif
	call SelectBtwCols(l:sln, l:spos, l:eln, l:epos)
endf

function! SetTitle(title)
	let l:escapedTitle = escape(a:title, ' \')
	execute 'set titlestring=' . l:escapedTitle
	set title
endfunction
command! -nargs=1 SetTitle :call SetTitle(<q-args>)

" get full path of all window of all tab, then save them into @* or @"
" depending on the availability of 'clipboard' option
function! ClipAllWinTabPaths()
	let l:lasttabnr = tabpagenr()

	if has('clipboard')
		let l:register = '*'
	else
		let l:register = '"'
	endif

	let l:patharr = []
	tabdo windo call AddUniq(l:patharr, expand('%:p'))
	call setreg(l:register, join(l:patharr, "\n"))

	execute "tabnext " . l:lasttabnr

	if !has('clipboard')
		$ tabnew
		put
		global/^$/delete
	endif
endfunction
command! ClipAllWinTabPaths :call ClipAllWinTabPaths()

" Open files on each line one file in one tab
function! OpenFileOnEachLine() range
	" silent global/^$/delete
	" let l:linecnt = 1
	let l:cmd = ""
	" let l:totallinenum = line("$")
	" call cursor(1, 1)
	for l:linenum in range(a:firstline, a:lastline)
		call cursor(l:linenum, 1)
		let l:path = expand("<cfile>")
		if !filereadable(l:path)
			continue
		endif
		let l:cmd .= "tabnew ".l:path." \<Bar> "
	endfor
	" while l:linecnt <= l:totallinenum
	"     call cursor(l:linecnt, 1)
	"     let l:cmd = l:cmd . "tabnew " . expand("<cfile>") . " \<Bar> "
	"     let l:linecnt = l:linecnt + 1
	" endwhile
	execute l:cmd
endfunction
command! -range=% OpenFileOnEachLine <line1>,<line2>call OpenFileOnEachLine()

" Open multiple files each in its own tab
" @... [path[]] Filepath to open. Wildcard is accepted.
function! TabnewMulti(...)
	let l:files = []
	for l:paths in a:000
		for l:node in glob(l:paths, 0, 1)
			" Get absolute path or it fails when the arguments contains
			" recursive wildcard and the expanded result contains files in
			" subdirectory as autocmd changes pwd to the file's containing
			" dirctory and relative path breaks.
			" Also exclude directories.
			if filereadable(l:node)
				call add(l:files, fnamemodify(l:node, ':p'))
			endif
		endfor
	endfor
	let l:filenum = len(l:files)
	if l:filenum == 0
		echohl WarningMsg | echo 'No matching file' | echohl NONE
		return
	endif
	let l:orgtabnr = tabpagenr()
	for l:file in l:files
		execute 'tabnew '.l:file
	endfor
	execute l:orgtabnr.'tabnext'
	" FIXME this message is not displayed
	echo printf('%s file%s opened', l:filenum, l:filenum > 1 ? 's' : '')
endfunction
command! -complete=file -nargs=+ TabnewMulti call TabnewMulti(<f-args>)

function! OutputEditorCmdToPreview(cmd) abort
	let l:org_reg_contents = @@
	redir @">
	try
		silent execute a:cmd
	catch
		echohl ErrorMsg | echo v:exception | echohl NONE
		let @@ = l:org_reg_contents
		return
	finally
		redir END
	endtry

	execute printf('pedit +file\ [%s] %s', escape(a:cmd, ' \'), tempname())
	wincmd P
	%delete _
	put "
	0delete _
	set nomodified

	let @@ = l:org_reg_contents
endfunction
command! -complete=command -nargs=+ OutputEditorCmdToPreview call OutputEditorCmdToPreview(<q-args>)

function! SetOperatorFunc(funcname)
	execute 'set operatorfunc=' . a:funcname
	echohl Identifier | echon a:funcname | echohl NONE
	echon ' is being called. Enter motion key:'
endfunction

function! GetOperatorText(operatortype, noline)
	if a:operatortype ==# 'v'
		normal! `<v`>y
	elseif a:operatortype ==# 'char'
		normal! `[v`]y
	else
		if a:noline
			echohl WarningMsg
			echo "line-wise motion and line/block-wise selection is not supported"
			echohl NONE
			throw "Exception"
		endif

		normal! `[V`]y
	endif
	return @"
endfunction

function! GetVisualText()
	normal! gvy
	let l:result = getreg('"')
	normal! gv
	return l:result
endfunction

" Get ftplugins (including after) for the specified file type and return them as a list
function! GetFtplugins(filetype)
	let l:files = []
	let l:trailingfn = '/ftplugin/'.a:filetype.'.vim'
	let l:ftppath = s:vimdir.l:trailingfn
	let l:aftppath = s:vimdir.'/after'.l:trailingfn

	if filereadable(l:ftppath)
		call add(l:files, l:ftppath)
	endif
	if filereadable(l:aftppath)
		call add(l:files, l:aftppath)
	endif

	return l:files
endfunction

" Open ftplugin (including after) for the specified file type
function! OpenFtplugins(...)
	let l:files = []
	for l:ft in a:000
		let l:files += GetFtplugins(l:ft)
	endfor

	if empty(l:files)
		redraw
		echo 'No ftplugins found'
		return
	endif

	for l:file in l:files
		silent execute 'tabnew '.l:file
	endfor
endfunction
command! -complete=filetype OpenFtplugins :call OpenFtplugins(<f-args>)

" Set filetype again with the current buffer's file type
function! SetFt(...)
	execute 'set filetype=' . get(a:000, 0, &filetype)
endfunction
command! -nargs=? -complete=filetype SetFt :call SetFt(<f-args>)
cnoreabbrev sf SetFt

" 'lmake' without moving to location list window
function! MyMake(...) abort
	let l:cmd = 'silent lmake! '.join(a:000)
	echohl Identifier | echo 'Making... ' | echohl NONE
	execute l:cmd
	let l:errorexists = qf#base#QFOpenSmart(g:qf#base#qf_mode_location, v:false, 0)
	" On linux console, bash console will be shown when making and vim is
	" brought back when make is done. This causes the contents of the file now
	" shown properly. 'redraw!' to fix it.
	if !(has('gui') || has('nvim'))
		redraw!
	endif
	if l:errorexists
		echohl WarningMsg | echon 'Failed :(' | echohl NONE
	else
		echohl Identifier | echon 'Done!' | echohl NONE
	endif
endfunction
command! -nargs=* MyMake :call MyMake(<f-args>)

" Solution for restoring window height inside <expr> keymap
" (<expr> does not allow `windo`)
function! SaveWinheight() abort
	let l:winheights = {}
	for i in range(1, winnr('$'))
		let l:winheights[win_getid(i)] = winheight(0)
	endfor

	function! l:winheights.restore() abort
		for i in range(1, winnr('$'))
			execute "resize " . self[win_getid(i)]
		endfor
	endfunction

	return l:winheights
endfunction

" Display dictionary in accending order
function! DispOptions(title, option, message, ...) abort
	let l:SortFunc = get(a:000, 0, '')
	let l:key_name = get(a:000, 1, '')

	echohl Statement | echo a:title | echohl NONE
	for [k,v] in sort(items(a:option), l:SortFunc)
		echo printf('  %s: %s', k, (type(v) == v:t_dict ? v[l:key_name] : v))
	endfor
	unlet k v
	echohl Function | echo a:message | echohl NONE
endf

" Display dictionary in accending order in oneline
function! DispOptionsOneLine(title, option, ...) abort
	let l:SortFunc = get(a:000, 0, '')
	let l:key_name = get(a:000, 1, '')

	echohl Function | echo printf('-- %s -> %s: ', a:title, DictToOneLineString(a:option, ', ', l:SortFunc, l:key_name)) | echohl NONE
endf

function! DictToOneLineString(dict, ...) abort
	let l:separator = get(a:000, 0, ', ')
	let l:SortFunc = get(a:000, 1, '')
	let l:key_name = get(a:000, 2, '')

	let l:output = []
	for [k,v] in sort(items(a:dict), l:SortFunc)
		call add(l:output, printf('%s[%s]', (type(v) == v:t_dict ? v[l:key_name] : v), k))
	endfor
	return join(l:output, l:separator)
endfunction

function! Toggler()
	let l:options = {
				\ 'l': 'list',
				\ 'p': 'paste',
				\ 'r': 'relativenumber',
				\ 'w': 'wrap'
				\ }
	call DispOptions('Toggle option', l:options, 'Press a key: ')
	let l:userinput = GetChar(v:true)
	" string == 0 is true so must return the default value
	let l:option = get(l:options, l:userinput, "")
	redraw	" clear concole so that 'Press ENTER or ...' will not be shown
	if l:option is ""
		" user press an unavailable key
		echohl WarningMsg
		echo printf('"%s" is not available.', l:userinput)
		echohl NONE
		return
	endif
	execute 'set '.l:option.'! '.l:option.'?'
endf
nnoremap _ :call Toggler()<CR>

" Function for sort() to sort 2D list based on the first element of inner array.
" Main usage is to sort list returned by items({dict}).
" Default algorithm of sort() has case insensitive sorting, but it does not
" guarantee that either UPPERCASE or lowercase precedes the other.
" This sort place lowercase before UPPERCASE within the same letter.
function! SortItemsCaseIns(one, two)
	let [l:key1, l:key2] = [a:one[0], a:two[0]]
	if l:key1 ==# l:key2
		return 1
	endif
	if l:key1 ==? l:key2
		" same char but different case -> lowercase should precedes UPPERCASE
		return char2nr(l:key1) > char2nr(l:key2) ? -1 : 1
	endif
	return l:key1 > l:key2 ? 1 : -1
endfunction

" Function for sort() to sort 2D list based on the second element of inner array.
" Main usage is to sort list returned by items({dict}).
" This essentially sort dict by value.
function! SortItemsByValue(one, two)
	return a:one[1] > a:two[1] ? 1 : -1
endfunction

" Like SortItemsByValue() but use nested value
function! SortItemsByNestedValue(key, one, two)
	return a:one[1][a:key] > a:two[1][a:key] ? 1 : -1
endfunction

function! s:diff(...)
	if a:0 != 2
		echoerr 'Diff takes exactly 2 arguments'
		return
	endif

	let l:msgFileNotExists = '%s does not exist'
	if !filereadable(a:1)
		echoerr printf(l:msgFileNotExists, a:1)
		return
	endif
	if !filereadable(a:2)
		echoerr printf(l:msgFileNotExists, a:2)
		return
	endif

	let l:fullpath1 = fnamemodify(a:1, ';p')
	let l:fullpath2 = fnamemodify(a:2, ';p')
	execute 'tabnew '.l:fullpath1
	execute 'diffsplit '.l:fullpath2
endfunction
command! -complete=file -nargs=+ Diff :call s:diff(<f-args>)

function! IsRegMultiline(reg)
	let l:reg_content = getreg(a:reg)
	return match(l:reg_content, '\r\|\n') >= 0
endfunction

" Capture the result of find & grep in quickfix window
function! CaptureFindGrep(cmd) abort
	let l:results = systemlist(a:cmd)
	if v:shell_error
		redraw
		echohl WarningMsg | echo join(l:results) | echohl NONE
		return
	endif
	if empty(l:results)
		redraw
		echo 'No match found'
		return
	endif

	let l:qflists = []
	call setqflist([], ' ', {'lines': l:results,'title': a:cmd})
	call qf#base#QFOpenSmart(g:qf#base#qf_mode_quickfix, v:false, 0)
endfunction
command! -complete=file -nargs=1 CaptureFindGrep call CaptureFindGrep(<q-args>)
cnoreabbrev fig CaptureFindGrep find -type f -exec grep -Hn {} \\;<C-Left><C-Left><Left>

function! InstallPluginManager()
	if !executable('git')
		echo 'Install `git` first'
		return
	endif

	!git clone https://github.com/junegunn/vim-plug.git ~/.vim/bundle/vim-plug
endfunction

function! RunInNewTabTerminal(shellCmd, focus) abort
	let l:vimCmd = 'tab split term://' . a:shellCmd
	if a:focus
		let l:vimCmd .= ' | startinsert'
	endif
	execute l:vimCmd
endfunction
command! -complete=shellcmd -nargs=+ -bang RunInNewTabTerminal call RunInNewTabTerminal(<q-args>, <bang>0)

function! DeleteHiddenBuffers()
	let tpbl = []
	call map(range(1, tabpagenr('$')), 'extend(tpbl, tabpagebuflist(v:val))')

	let l:hidden_bufs = filter(range(1, bufnr('$')), 'bufexists(v:val) && index(tpbl, v:val) == -1')

	for l:hidden_buf in l:hidden_bufs
		silent execute 'bwipeout' l:hidden_buf
	endfor
endfunction
command! DeleteHiddenBuffers call DeleteHiddenBuffers()
" --- || functions || }}}

" load local vimrc
if exists('g:plugs["vim-projectroot"]')
	silent! execute 'source '.projectroot#guess().'/.vimrc_local'
endif
