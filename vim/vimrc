" {{{ || variables || ---
" filereadable() does not expand ~ (tilde) to home directory.
" Workaround is to use $HOME or expand()
let s:vimdir = expand("~/.vim")
" --- || variables || }}}

" {{{ || plugin || ---
" {{{ || vim-polyglot || ---
" This must be prior to plugin loading
let g:polyglot_disabled = ['vim']
" --- || vim-polyglot || }}}

if has('nvim')
  packadd cfilter
  packadd termdebug
endif
" Loadng plugins must be before keymapping or they will override my keymappings!
let s:plugin_dir = s:vimdir . '/bundle'
let s:vim_plug_file = s:plugin_dir . '/vim-plug/plug.vim'
if filereadable(s:vim_plug_file)
  execute 'source ' . s:vim_plug_file
  call plug#begin(s:plugin_dir)
  Plug 'junegunn/vim-plug'
  " Plug 'vim-denops/denops.vim'
  " git
  Plug 'tpope/vim-fugitive'
  Plug 'airblade/vim-gitgutter'
  Plug 'zivyangll/git-blame.vim'
  " look & feel
  Plug 'vim-airline/vim-airline'
  Plug 'vim-airline/vim-airline-themes'
  " finder (path/dir/file/buffer/tac/etc.)
  Plug 'preservim/nerdtree'
  if executable('ranger')
    Plug 'francoiscabrol/ranger.vim'
    Plug 'rbgrouleff/bclose.vim' " ranger.vim depends on it
  endif
  Plug 'preservim/tagbar'
  Plug 'ctrlpvim/ctrlp.vim'   " required by vim-go GoDecls
  Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
  Plug 'junegunn/fzf.vim'
  Plug 'tpope/vim-projectionist'
  Plug 'c-brenn/fuzzy-projectionist.vim'
  Plug 'folke/which-key.nvim'
  " moving around
  Plug 'easymotion/vim-easymotion'
  Plug 'michaeljsmith/vim-indent-object'
  Plug 'jeetsukumaran/vim-indentwise'
  Plug 'bkad/CamelCaseMotion'
  " editting
  Plug 'bfredl/nvim-miniyank'
  Plug 'editorconfig/editorconfig-vim'
  Plug 'Yggdroot/indentLine'
  Plug 'preservim/nerdcommenter'
  Plug 'arthurxavierx/vim-caser'
  Plug 'tpope/vim-surround'
  Plug 'jiangmiao/auto-pairs'
  Plug 'AndrewRadev/splitjoin.vim'
  Plug 'tpope/vim-repeat'
  Plug 'junegunn/vim-easy-align'
  Plug 'neomake/neomake'
  if has('nvim') " no completion for conventional vim as it takes so long to start up
    Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
  endif
  " Plug 'Shougo/ddc.vim'
  " Plug 'Shougo/ddc-nvim-lsp'
  Plug 'Shougo/echodoc.vim'
  Plug 'autozimu/LanguageClient-neovim', {
        \ 'branch': 'next',
        \ 'do': has('win32') ? 'powershell install.ps1' : 'bash install.sh',
        \ }
  " Plug 'neovim/nvim-lspconfig'
  " Plug 'simrat39/rust-tools.nvim'
  " Plug 'SirVer/ultisnips'
  Plug 'honza/vim-snippets'
  Plug 'Shougo/neosnippet.vim'
  " Plug 'Shougo/deoppet.nvim' " snipmate not supported yet
  Plug 'Shougo/neosnippet-snippets'
  Plug 'vim-utils/vim-husk'
  " misc
  Plug 'ahmedkhalf/project.nvim'
  Plug 'sheerun/vim-polyglot'
  Plug 'tpope/vim-abolish'
  Plug 'vim-test/vim-test'
  Plug 'tmux-plugins/vim-tmux-focus-events'
  Plug 'tyru/open-browser.vim'

  " Language specific
  " <fish>
  Plug 'dag/vim-fish'
  " <js>
  Plug 'moll/vim-node'
  " <go>
  Plug 'fatih/vim-go', { 'tag': '*' } " Do not run `GoUpdateBinaries` post-hook as it takes a long time
  " <java>
  if executable('java')
    Plug 'artur-shaik/vim-javacomplete2' " complains if there is no java executable
  endif
  " <php>
  if executable('composer')
    Plug 'phpactor/phpactor', {'branch': 'master', 'do': 'composer install --no-dev -o'}
  endif
  Plug 'rust-lang/rust.vim'
  Plug 'vim-php/tagbar-phpctags.vim'
  Plug 'stephpy/vim-php-cs-fixer'
  Plug 'noahfrederick/vim-laravel'
  " <wiki>
  Plug 'vimwiki/vimwiki'
  " <markdown>
  Plug 'iamcco/markdown-preview.nvim', { 'do': { -> mkdp#util#install() }}
  Plug 'mzlogin/vim-markdown-toc'
  Plug 'dhruvasagar/vim-table-mode'
  " <plantuml>
  Plug 'weirongxu/plantuml-previewer.vim'
  call plug#end()
else
  " these are called by plug#end()
  filetype plugin indent on
  syntax enable
endif
" --- || plugin || }}}

" lua << EOF
"   require('lspconfig').rust_analyzer.setup{}
"   -- local opts = { noremap=true, silent=true }
"   local opts = { noremap=true }
"   vim.api.nvim_set_keymap('n', 'K', '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)

"   require('rust-tools').setup({
"     server = {
"       cmd = { "rustup", "run", "nightly", "rust-analyzer" }
"     },
"   })
" EOF

" {{{ || options || ---

" << system >>
set nocompatible            " do not use legacy mode
set encoding=utf-8
set fileencodings^=utf-8
if has('unix')
  set shell=/bin/bash
endif

" << looks and feel >>
set background=dark           " color scheme for dark background
if v:version >= 800           " suppress bell sound and flushing
  set belloff=all
else
  set visualbell t_vb=
endif
set t_Co=256              " enrich color
set number " relativenumber       " show line number and distance relative to current line
if !&diff && (has('gui') || has('unix') || has('nvim'))
  set cursorline            " current line is underlined
endif
set nomodeline              " modeline brings security issue?
set nowrap                " line does not wrap
set scrolloff=5 sidescrolloff=1     " offset between cursor and the edge of window"
set sidescroll=1            " scroll minimal when cursor goes off the screen horizontally
if has('gui')
  set title
endif
set titlestring=%{getcwd()}       " current directory
set titlestring+=\ \|\ %F%a       " full path to the file and argument list info
if !empty(v:servername)
  set titlestring+=\ \|\ %{v:servername}  " server name such as 'VIM'
endif
set laststatus=2            " always display status bar
set showtabline=2           " always display tabline
set shortmess+=c
set conceallevel=2
set concealcursor=nv

" {{{ || Compose tabline || ---
function! MyTabLine()
  let l:max_fname_length = 20
  let l:tabline = ''
  for l:cnt in range(tabpagenr('$'))
    let l:tabpagecnt = l:cnt + 1

    " select the highlighting
    if l:tabpagecnt == tabpagenr()
      let l:tabline .= '%#TabLineSel#'
    else
      let l:tabline .= '%#TabLine#'
    endif

    " compose tabline
    let l:tabline .= ' '
    " Add '+' if one of the buffers in the tab page is modified
    let l:buflist = tabpagebuflist(l:tabpagecnt)
    " Add '+' if one of the buffers in the tab page is modified
    for l:bufnr in l:buflist
      if getbufvar(l:bufnr, "&modified")
        let l:tabline .= '+'
        break
      endif
    endfor
    " Add tab number
    let l:tabline .= l:tabpagecnt
    " Add window number if more than 1 is opened
    let l:wincnt = tabpagewinnr(l:tabpagecnt, '$')
    if l:wincnt > 1
      let l:tabline .= ':' . l:wincnt
    endif
    let l:tabline .= ' '
    " Add file name
    let l:winnr = tabpagewinnr(l:tabpagecnt)
    let l:curbufnr = l:buflist[l:winnr - 1]
    let l:fname = bufname(l:curbufnr)
    let l:fnamelen = strlen(l:fname)
    if l:fnamelen == 0
      " TODO distinguish Location List and Quickfix List
      if getbufvar(l:curbufnr, "&filetype") ==# 'qf'
        let l:tabline .= '[Loc List]'
      else
        let l:tabline .= '[No Name]'
      endif
    else
      let l:modified_fname = fnamemodify(l:fname, ':t')
      let l:fnamelen = len(l:modified_fname)
      if l:fnamelen > l:max_fname_length
        let l:modified_fname = l:modified_fname[l:fnamelen-l:max_fname_length:]
      endif
      let l:tabline .= l:modified_fname
    endif
    let l:tabline .= ' '
  endfor

  " after the last tab fill with TabLineFill
  let l:tabline .= '%#TabLineFill#'

  return l:tabline
endfunction

set tabline=%!MyTabLine()
" --- || Compose tabline|| }}}

" reverse the color of unselected tab
highlight TabLine term=reverse cterm=bold,reverse gui=reverse

" << editing >>
set tabstop=4 noexpandtab shiftwidth=4  " change tab width
set autoindent smartindent              " indentation support
set shiftround                          " round tab width for > and < command
set fileformats=unix,dos,mac            " Prefer Unix over Windows over OSX formats
set listchars=tab:\|\                   " Show unvisible chars
set backspace=indent,eol,start          " Enable backspace to wrap line and delete break
set virtualedit=block                   " Allow cursor to move beyond the EOL when visual-block mode
set iminsert=0 imsearch=-1              " prevent entering Japaneve input mode when entering insert and search mode
set shellslash                          " always use forward slash
set formatoptions+=jmM
set nofixendofline                      " Preserve the current EOL state
set timeoutlen=600
set ttimeoutlen=0                       " This prevents <Esc> to hang in input mode on Linux terminal
if has('persistent_undo')
  if !isdirectory($HOME . '/.vim/undo')
    call mkdir($HOME . '/.vim/undo', 'p')
  endif
  set undofile                          " enable undo beyond sessions
  set undodir=$HOME/.vim/undo,.
endif

" << search >>
set ignorecase              " Do case insensitive matching
set smartcase             " Do smart case matching
set incsearch             " Incremental search
set hlsearch              " highlight the match
set matchpairs+=<:>           " % command jumps between <> as well

" << others >>
if !isdirectory($HOME . '/.vim/swap')
  call mkdir($HOME . '/.vim/swap', 'p')
endif
set directory=$HOME/.vim/swap,.
set cpoptions+=Iy           " I:autoindent is not removed when moving to other lines
set whichwrap+=<,>            " allow <Left> and <Right> in move to other lines
set complete+=k             " ins-completion option (include dictionary search)
set completeopt=longest,menuone,preview " ins-completion mothod (complete to longest, display menu even though only one match)
set splitbelow splitright       " splitted windows goes to below or right
set showcmd               " Show (partial) command in status line.
set lazyredraw              " screen will not be redrawn till macro execution is done
set tags=./tags;,./TAGS;,tags;,TAGS;
set diffopt+=vertical
set sessionoptions=blank,curdir,folds,tabpages,winsize

" << command mode >>
set history=1000
set wildignorecase            " command mode completion ignores case
set wildignore+=*.swp,*.bak,*.class   " ignore files this specified extentions on completion
set wildmenu              " display menu on command line completion
" neosnippet behaves strangely if 'wildcharm' is set to <Tab>, so use another key to workaround
" set wildcharm=<Tab>           " This enables cycling through popup version of wildmenu with <expr> keymap
set wildcharm=<F10>
set wildmode=full,longest:full      " command mode completion method
" --- || options || }}}

" {{{ || highlight || ---
highlight Pmenu ctermfg=254 ctermbg=22 gui=bold guibg=Blue
highlight ColorColumn ctermbg=6 guibg=DarkCyan
" --- || highlight || }}}

" {{{ || automatically enter paste mode when pasting || ---
if &term =~ "xterm"
  let &t_ti .= "\e[?2004h"
  let &t_te .= "\e[?2004l"
  let &pastetoggle="\e[201~"

  function! XTermPasteBegin(command)
    set paste
    return a:command
  endfunction

  nnoremap <special> <expr> <Esc>[200~ XTermPasteBegin("i")
  " This delays exiting Insert and Command mode by pressing <Esc>
  " inoremap <special> <expr> <Esc>[200~ XTermPasteBegin("")
  " cnoremap <special> <Esc>[200~ <Nop>
  " cnoremap <special> <Esc>[201~ <Nop>
endif
" --- || automatically enter paste mode when pasting || }}}

" {{{ || enable meta-key bindings || ---
if !get(s:, 'meta_key_bound') && has('unix') && !has('nvim')
  " fix meta-keys which generate <Esc>a .. <Esc>z
  " do this once only so that keymaps defined by plugin will not be overwritten with <Nop>
  let s:set_meta_to_esc = "set <M-%s>=\e%s"
  let s:map_esc_to_meta = "noremap%s \e%s <M-%s>"
  let s:map_meta_to_nop = "noremap%s <M-%s> <Nop>"
  let c = 'a'
  while c <= 'z'
    " lower case
    exec printf(s:set_meta_to_esc, c, c)
    exec printf(s:map_esc_to_meta, '!', c, c)
    exec printf(s:map_esc_to_meta, '', c, c)
    exec printf(s:map_meta_to_nop, '!', c)
    exec printf(s:map_meta_to_nop, '', c)
    " upper case - skip M-O as it is part of del key, ins key, F key and etc
    if c != 'o'
      let C = toupper(c)
      exec printf(s:set_meta_to_esc, C, C)
      exec printf(s:map_esc_to_meta, '!', C, C)
      exec printf(s:map_esc_to_meta, '', C, C)
      exec printf(s:map_meta_to_nop, '!', C)
      exec printf(s:map_meta_to_nop, '', C)
    endif
    let c = nr2char(1+char2nr(c))
  endwhile
  unlet c C

  " meta + special-keys
  " note: '[' cannot be mapped as it's part of some keycodes
  exec "set <M-$>=\e$"
  exec "set <M-#>=\e#"
  exec "set <M-*>=\e*"
  exec "set <M-+>=\e+"
  exec "set <M-->=\e-"
  exec "set <M-/>=\e/"
  exec "set <M-:>=\e:"
  exec "set <M-;>=\e;"
  exec "set <M-=>=\e="
  " exec "set <M-]>=\e]" " This causes vim to work funny
  exec "set <M-_>=\e_"
  exec "set <M-`>=\e`"

  for n in range(0, 9)
    exec "set <M-".n.">=\e".n
    exec "noremap! \e".n." <M-".n.">"
    exec "noremap \e".n." <M-".n.">"
    exec "noremap <M-".n."> <Nop>"
  endfor
  unlet n
endif
let s:meta_key_bound = 1
" --- || enable meta-key bindings || }}}

" {{{ || autocmd || ---
" augroup prevents duplicated effect by disabling previous effect of the same group
if has("autocmd")
  augroup buffer_init
    autocmd!
    " jump to the last position when reopening a file
    autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
  augroup END

  " highlight for unwanted spaces
  highlight AnnoyingSpaces ctermbg=237
  augroup highlighter
    autocmd!
    " highlight trailing whitespaces and mixed whitespaces except for help files
    " VimEnter does not do the job somehow
    if has('nvim')
      " SpellRare (under curl) does not work on nvim
      autocmd BufWinEnter,InsertEnter,InsertLeave * match AnnoyingSpaces /\s\+$\| \+\t\+\|\t\+ \+/
    else
      autocmd BufWinEnter,InsertEnter,InsertLeave * match SpellRare /\s\+$\| \+\t\+\|\t\+ \+/
    endif
    autocmd FileType help silent! call matchdelete(1)
  augroup END

  function! s:PreviousTabStoreState()
    let s:tab_current = tabpagenr()
    let s:tab_last = tabpagenr('$')
  endfunction
  function! s:PreviousTabTabClosed()
    if s:tab_current > 1 && s:tab_current < s:tab_last
      exec 'tabp'
    endif
  endfunction
  augroup prev_tab
    autocmd!
    autocmd TabEnter,TabLeave * call s:PreviousTabStoreState()
    autocmd TabClosed * call s:PreviousTabTabClosed()
  augroup end

  augroup misc
    autocmd!
    " fix windows size on resizing vim
    autocmd VimResized * :wincmd =
    " disable relativenumber in quickfix window
    autocmd FileType qf setlocal norelativenumber
    " if has('nvim')
      " automatically enter terminal-mode
      " XXX this causes GoRun to enter insert mode
      " autocmd TermOpen * startinsert
    " endif
    " paired with completeopt=preview
    autocmd CompleteDone * pclose
  augroup END
endif
" --- || autocmd || }}}

" {{{ || key mapping || ---

" {{{ || Leader || ---
noremap <Space> <Nop>
let mapleader = "\<Space>"

" Use local leader for ftplugins
" let maplocalleader = "\<C-Space>"

let g:vert_key = "\<C-Space>"
map <C-Space> [Vert]

map ; [Chief]
let g:chief_key = ';'
if has('xterm_clipboard')
  nnoremap [Chief] "+
  vnoremap [Chief] "+
else
  nnoremap [Chief] "*
  vnoremap [Chief] "*
endif

map , [Captain]
nnoremap [Captain] "_
vnoremap [Captain] "_
" --- || Leader || }}}

" {{{ || cursor motion || ---
noremap j gj
noremap k gk
noremap <expr> <silent> <Home> col('.') == match(getline('.'),'\S')+1 ? '0' : '^'
map H <Home>
nnoremap L $
onoremap L $
vnoremap L g_
" J & K below is to prevent accidental line join and opening help
vnoremap J j
vnoremap K k

snoremap <C-f> <Right>
snoremap <C-b> <Left>
snoremap <C-p> <Up>
snoremap <C-n> <Down>
snoremap <M-f> <S-Right>
snoremap <M-b> <S-Left>
snoremap <M-p> <S-Up>
snoremap <M-n> <S-Down>
snoremap <C-i> <ESC>i

" {{{ || insert/command mode || ---
inoremap <C-b> <Left>
inoremap <C-f> <Right>
inoremap <M-f> <C-Right>
inoremap <M-b> <C-Left>
inoremap <M-e> <Esc>ea
inoremap <M-E> <Esc>Ea
inoremap <M-e> <Esc>ea
inoremap <M-E> <Esc>Ea
imap <silent> <Home> <C-o><Home>
imap <C-a> <Home>
inoremap <expr> <C-e> pumvisible() ? "\<C-e>" : "\<End>"
inoremap <C-p> <Up>
inoremap <C-n> <Down>
" --- || insert/command mode || }}}

" [always search forward/backword]
" noremap <expr> <Bslash> getcharsearch().forward ? ';' : ','
" noremap <expr> <Bar> getcharsearch().forward ? ',' : ';'
vnoremap al ggoG$
" all
onoremap <silent> al :normal! VggoG<CR>
" line without indent
onoremap <silent> u :normal! ^v$h<CR>
" line including indent
onoremap <silent> U :normal! 0v$h<CR>
" XXX these do not work if the cursor is on the last element
" as in /cursor/is/he|re
onoremap <silent> ad :call SelectPair('${', '', '}', 1)<CR>
vnoremap <silent> ad :<C-u>call SelectPair('${', '', '}', 1)<CR>
onoremap <silent> ie :call SelectElement()<CR>
vnoremap <silent> ie :<C-u>call SelectElement()<CR>
vnoremap <silent> i, T,ot,
onoremap <silent> i, :normal! T,vt,<CR>
vnoremap <silent> a, T,of,
onoremap <silent> a, :normal! T,vf,<CR>
vnoremap <silent> i. T.ot.
onoremap <silent> i. :normal! T.vt.<CR>
vnoremap <silent> a. T.of.
onoremap <silent> a. :normal! T.vf.<CR>
vnoremap <silent> i/ T/ot/
onoremap <silent> i/ :normal! T/vt/<CR>
vnoremap <silent> a/ T/of/
onoremap <silent> a/ :normal! T/vf/<CR>
vnoremap <silent> iu T_ot_
onoremap <silent> iu :normal! T_vt_<CR>
vnoremap <silent> au T_of_
onoremap <silent> au :normal! T_vf_<CR>
function! VisualOperator(operatortype)
  if a:operatortype ==# 'v'
    normal! `<v`>
  else
    normal! `[v`]
  endif
endfunction
" --- || cursor motion || }}}

" {{{ || scrolling || ---
noremap <C-u> 10<C-y>
noremap <C-d> 10<C-e>
noremap <M-y> zh
noremap <M-e> zl
noremap <M-Y> zH
noremap <M-E> zL
" --- || scrolling || }}}

" {{{ || tag || ---
nnoremap [t <C-t>
nnoremap ]t :tag<CR>
" --- || tag || }}}

" {{{ || editing || ---
nnoremap <M-x> "_x
nnoremap <M-X> "_X
nnoremap =p =']
vnoremap p "_c<C-r>"<Esc>
vnoremap P "_c<C-r>"<Esc>
" [insert/command mode]
noremap! <C-Space> <Space><Left>
inoremap <C-w> <C-g>u<C-w>
inoremap <C-u> <C-g>u<C-u>
cnoremap <expr> <C-q> Expander()
inoremap <expr> <C-y> pumvisible() ? "\<C-y>" : "<C-g>u\<C-r>\""
cnoremap <expr> <C-y> wildmenumode() ? "\<C-y>" : "\<C-r>\""
" cnoremap <expr> <Tab> wildmenumode() ? "\<C-n>" : "\<Tab>"
cnoremap <expr> <Tab> wildmenumode() ? "\<C-n>" : "\<F10>"
cnoremap <expr> <C-g> wildmenumode() ? "\<Down>" : "\<C-g>"
cnoremap <expr> <C-t> wildmenumode() ? "\<Up>" : "\<C-t>"
noremap! <M-y> <C-r>*
inoremap <C-d> <DEL>
inoremap <M-d> <C-g>u<C-\><C-o>"_dw
inoremap <C-k> <C-g>u<C-\><C-o>"_D
inoremap <M-h> <C-g>u<C-w>
cnoremap <M-h> <C-w>
inoremap <M-t> <C-d>
" [UPPER/lowercase & Capitalize]
inoremap <M-u> <Esc>gUiwea
inoremap <M-l> <Esc>guiwea
inoremap <M-c> <Esc>guiwgU<right>ea
" [Line break/join]
nnoremap <expr> <CR> &filetype == 'qf' ? "\<CR>" : "i\<CR>\<Esc>"
nnoremap <M-m> mpo<Esc>0Dg`p| "insert blank line below
nnoremap <M-M> mpO<Esc>0Dg`p| "insert blank line above
nnoremap <M-o> o<Esc>
nnoremap <M-O> O<Esc>
nnoremap <C-j> i<CR><Esc><Up><End>a
" [Other editing]
vnoremap y ygv<Esc>|  "place cursor after the selection when yanking
nnoremap Y y$
vnoremap <silent> <C-a> <C-a>gv
vnoremap <silent> <C-x> <C-x>gv
nnoremap <silent> g<C-a> :call search("[0-9]", 'be', line('.'))<CR><C-a>
nnoremap <silent> g<C-x> :call search("[0-9]", 'be', line('.'))<CR><C-x>
nnoremap d. /\s\+$<CR>"_dgn|  " delete trailing spaces
inoremap <silent> <M-,> <Cmd>call edit#base#ToggleTrailing(',')<CR>
nnoremap <silent> <M-,> <Cmd>call edit#base#ToggleTrailing(',')<CR>
vnoremap <silent> <M-,> :call edit#base#ToggleTrailing(',')<CR>
" [move line]
" nnoremap <silent> <expr> <M-j> ":\<C-u>silent! move .+".v:count1."\<CR>=="
" nnoremap <silent> <expr> <M-k> ":\<C-u>silent! move .-".(v:count1+1)."\<CR>=="
" ones for visual mode requires range ('<,'>) to work as intended
" vnoremap <silent> <expr> <M-j> ":\<C-u>silent! '<,'>move '>+".(v:count1)."\<CR>gv=gv"
" vnoremap <silent> <expr> <M-k> ":\<C-u>silent! '<,'>move '<-".(v:count1+1)."\<CR>gv=gv"
" [undo redo]
nnoremap U <Nop>
inoremap <C-_> <C-o>u
inoremap <C-/> <C-o>u
inoremap <M-/> <C-o><C-r>
" [set undo break before commands below]
inoremap <Space> <C-g>u<Space>
inoremap <C-m> <C-g>u<C-m>
inoremap . .<C-g>u
" --- || editing || }}}

" {{{ || register || ---
" used registers
" r: RedirCmdOutputToReg
" keymap for "z, "Z is defined in leader section
" nnoremap <Leader><Space> <Cmd>call register#base#CopyRegisterToAnother('"', 'z')<CR>
if has('xterm_clipboard')
  nnoremap [Chief]; <Cmd>call register#base#CopyRegisterToAnother('"', '+')<CR>
elseif has('clipboard')
  nnoremap [Chief]; <Cmd>call register#base#CopyRegisterToAnother('"', '*')<CR>
endif
nnoremap <Leader>r <Cmd>call register#base#CopyRegisterToAnotherInteract()<CR>
nnoremap [Chief]r <Cmd>call register#base#EditRegister()<CR>
nnoremap [Captain]r <Cmd>call register#base#ClearCharRegisters()<CR>
nnoremap yp <Cmd>let @* = expand('%:p') \| echo expand('%:p') 'copied to clipboard'<CR>
" --- || register || }}}

" {{{ || Mark || ---
noremap ' `
noremap ` '
nnoremap <Leader>m :<C-u>marks<CR>
" --- || Mark || }}}

" {{{ || Completion || ---
inoremap <expr> <C-l> pumvisible() ? "\<C-n>" : "\<C-x>\<C-n>"
inoremap <expr> <C-i> pumvisible() ? "\<C-n>" : "\<C-x>\<C-o>"
" --- || Completion || }}}

" {{{ || Search || ---
" AnnoyingSpaces: trailing white spaces or mixture of space and tab
let g:AnnoyingSpaces = "\\s\\+$\\| \\+\\t\\+\\|\\t\\+ \\+"
" open fold which the match belongs to so that you can view where exactly the
" match is.
nnoremap n nzx
nnoremap N Nzx
nnoremap <silent> [Captain]/ :let @/ = ''<CR>
function! HighlightWord(visual, exclusive, whole_word, case_sesitive) abort
  if a:visual
    let l:word = GetVisualText()
  else
    let l:word_range = a:whole_word ? '<cWORD>' : '<cword>'
    let l:word = expand(l:word_range)
  endif
  if a:exclusive
    let l:word = '\<' . l:word . '\>'
  endif
  if a:case_sesitive
    let l:word = '\C' . l:word
  endif

  call setreg('/', l:word)
  call histadd('search', l:word)
  " somehow this does not highlight
  " set hlsearch
endfunction
nnoremap <silent> * <Cmd>call HighlightWord(0, 0, 0, 0)<CR><Cmd>set hlsearch<CR>
nnoremap <silent> g* <Cmd>call HighlightWord(0, 1, 0, 0)<CR><Cmd>set hlsearch<CR>
nnoremap <silent> <M-*> <Cmd>call HighlightWord(0, 0, 0, 1)<CR><Cmd>set hlsearch<CR>
nnoremap <silent> g<M-*> <Cmd>call HighlightWord(0, 1, 0, 1)<CR><Cmd>set hlsearch<CR>
nnoremap <silent> <Leader>* <Cmd>call HighlightWord(0, 0, 1, 0)<CR><Cmd>set hlsearch<CR>
vnoremap <silent> * <Esc><Cmd>call HighlightWord(1, 0, 0, 0)<CR><Cmd>set hlsearch<CR>
vnoremap <silent> g* <Esc><Cmd>call HighlightWord(1, 1, 0, 0)<CR><Cmd>set hlsearch<CR>
if exists('v:hlsearch')
  nnoremap <silent> <expr> <M-u> (&hlsearch && v:hlsearch ? ':nohlsearch<CR>' : ':set hlsearch<CR>')
else
  nnoremap <silent> <M-u> :set hlsearch! hlsearch?<CR>
endif
" --- || Search || }}}

" {{{ || Grep || ---
" COMBAK make it like QuickSubstitute() and take dictionary arguments?
" Lets you run lvimgrep quickly and open quickfix window
" @pattern string to grep
" @modify when non-zero, let the user modify the argument for vimgrep
function! QuickGrep(pattern, modify)
  let l:vimgrep_cmd = 'lvimgrep '
  let l:grep_arg = printf('/\V%s/gj %%', a:pattern)

  if a:modify
    let l:cursor_adjustment = repeat("\<Left>", 5)
    let l:grep_arg = Input(v:true, ':' . l:vimgrep_cmd, l:grep_arg . l:cursor_adjustment)
    if l:grep_arg is 0
      return
    endif
  endif

  call histadd(':', l:vimgrep_cmd . l:grep_arg)
  try
    silent execute l:vimgrep_cmd . l:grep_arg
  catch /^Vim\%((\a\+)\)\=:E480/  " catch error E480 - No match found
    redraw
    echohl ErrorMsg | echomsg v:exception | echohl NONE
    silent lclose
    return
  endtry

  call qf#base#QFOpenSmart(g:qf#base#qf_mode_location, v:false, 0)
endfunction
lua << EOF
  local wk = require("which-key")
  wk.register({
    g = {
      name = "vimgrep",
      ["<Space>"] = { "<Cmd>call QuickGrep(expand('<cword>'), 0)<CR>", "<cword>" },
      x = { "<Cmd>call QuickGrep('\\<' . expand('<cword>') . '\\>', 0)<CR>", "<cword> exclusive" },
      [":"] = { "<Cmd>call QuickGrep('', 1)<CR>", "manual" },
    },
  }, { prefix = "<Leader>" })
  wk.register({
    g = {
      name = "vimgrep",
      ["<Space>"] = { "y<Cmd>call QuickGrep(@@, 0)<CR>", "selected" },
      x = { "y<Cmd>call QuickGrep('\\<' . @@ . '\\>', 0)<CR>", "selected exclusive" },
    },
  }, { prefix = "<Leader>", mode = "v" })
EOF
" --- || Grep || }}}

" {{{ || Replace || ---
" Lets you run substitute quickly
" @pattern string to find
" @options available options are:
"   range:     same as [range] command parameter.
"   selection: none-zero means search area is only within selection
"   case:      none-zero means case sensitive
"   exclusive: none-zero means pattern will be wrapped with \< \>
function! QuickSubstitute(core_pattern, options)
  let l:opt_key_range = 'range'
  let l:opt_key_case = 'case'
  let l:opt_key_exclusive = 'exclusive'
  let l:opt_key_selection = 'selection'
  let l:base_substitute_cmd = '%ssubstitute/\V%s//gc'

  let l:range = has_key(a:options, l:opt_key_range) ? a:options[l:opt_key_range] : ''

  let l:search_pattern = ''
  if has_key(a:options, l:opt_key_selection)
    let l:search_pattern .= a:options[l:opt_key_selection] ? '\%V' : ''
  endif
  if has_key(a:options, l:opt_key_case)
    let l:search_pattern .= a:options[l:opt_key_case] ? '\C' : ''
  endif
  " check for exclusive should be the last so that pattern string comes after ordinary atoms
  if has_key(a:options, l:opt_key_exclusive) && a:options[l:opt_key_exclusive] == 1
    let l:search_pattern .= '\<' . a:core_pattern . '\>'
  else
    let l:search_pattern .= a:core_pattern
  endif

  let l:substitute_cmd = printf(l:base_substitute_cmd, l:range, l:search_pattern)

  let l:cursor_adjustment = repeat("\<Left>", a:core_pattern is '' ? 4 : 3)
  let l:substitute_cmd = Input(v:true, ':', l:substitute_cmd . l:cursor_adjustment)
  if l:substitute_cmd is 0
    return
  endif

  call histadd(':', l:substitute_cmd)
  try
    execute l:substitute_cmd
  catch /^Vim\%((\a\+)\)\=:E486/  " catch error E486 - No match found
    redraw
    echohl ErrorMsg | echomsg v:exception | echohl NONE
  endtry
endfunction
lua << EOF
  local wk = require("which-key")
  wk.register({
    s = {
      name = "Substitute",
      ["<Space>"] = { "<Cmd>call QuickSubstitute(expand('<cword>'), {'range': '%'})<CR>", "case insensitive" },
      c = { "<Cmd>call QuickSubstitute(expand('<cword>'), {'range': '%', 'case': 1})<CR>", "case sensitive" },
      x = {
        name = "exclusive",
      ["<Space>"] = { "<Cmd>call QuickSubstitute(expand('<cword>'), {'range': '%', 'exclusive': 1})<CR>", "case insensitive" },
        c = { "<Cmd>call QuickSubstitute(expand('<cword>'), {'range': '%', 'exclusive': 1, 'case': 1})<CR>", "case sensitive" },
      },
      [":"] = { "<Cmd>call QuickSubstitute('', {'range': '%'})<CR>", "manual" },
      ["."] = { "<Cmd>call QuickSubstitute('', {})<CR>", "manual on current line" },
    },
  }, { prefix = "<Leader>" })
  wk.register({
    s = {
      name = "Substitute",
      ["<Space>"] = { "y<Cmd>call QuickSubstitute(@@, {'range': '%'})<CR>", "case insensitive" },
      c = { "y<Cmd>call QuickSubstitute(@@, {'range': '%', 'case': 1})<CR>", "case sensitive" },
      x = {
        name = "exclusive",
        ["<Space>"] = { "y<Cmd>call QuickSubstitute(@@, {'range': '%', 'exclusive': 1})<CR>", "case insensitive" },
        c = { "y<Cmd>call QuickSubstitute(@@, {'range': '%', 'exclusive': 1, 'case': 1})<CR>", "case sensitive" },
      },
      [":"] = { "<Esc><Cmd>call QuickSubstitute('', {'range': '%', 'selection': 1})<CR>", "manual within selection" },
    },
  }, { prefix = "<Leader>", mode = "v" })
EOF
" --- || Replace || }}}

" {{{ || Quickfix/Location || ---
nnoremap <silent> <C-q> <Cmd>call qf#base#QuickfixCmd(v:count)<CR>
" --- || Quickfix/Location || }}}

" {{{ || Buffer || ---
command! BufOnly %bdelete | edit#
" --- || Buffer || }}}

" {{{ || Window || ---
nnoremap <silent> <C-w>O :only!<CR>
nnoremap <C-w>B :bdelete<CR>
" --- || Window || }}}

" {{{ || Tab || ---
noremap <C-t> <Nop>
nnoremap <silent> <expr> <C-t><C-n> ":\<C-u>".(v:count ? v:count : "")."tabnew\<CR>"
nnoremap <silent> <expr> <C-t><C-o> ":\<C-u>".(v:count ? v:count : "")."tabonly\<CR>"
nnoremap <silent> <expr> <C-t><C-q> ":\<C-u>".(v:count ? v:count : "")."tabclose\<CR>"
nnoremap <silent> <expr> <C-t><C-d> ":\<C-u>".(v:count ? v:count : "")."tab split\<CR>"
nnoremap <silent> <C-t><CR> <C-w><CR><C-w>T
nnoremap <C-t><C-f> <C-w>gf
nnoremap <C-l> gt
nnoremap <C-h> gT
nnoremap <silent> <expr> <M-l> ":\<C-u>silent! tabmove+".v:count1."<CR>"
nnoremap <silent> <expr> <M-h> ":\<C-u>silent! tabmove-".v:count1."<CR>"
for n in range(1, 9)
  execute printf("nnoremap <M-%s> %sgt", n, n)
endfor
unlet n
nnoremap <M-0> 10gt
" jump to last active tab
if has('autocmd')
  let g:lasttabnum = 1
  augroup last_tab
    autocmd!
    autocmd TabLeave * let g:lasttabnum = tabpagenr()
  augroup END
  nnoremap <silent> <C-t><C-t> :execute "tabnext " . g:lasttabnum<CR>
endif
" --- || Tab || }}}

" {{{ || Suspend/Close/Exit || ---
nnoremap ZB :bdelete!<CR>
nnoremap ZT :windo quit!<CR>
nnoremap <C-w><C-a> :windo confirm quit<CR>
nnoremap <C-w>A :confirm qall<CR>
" --- || Suspend/Close/Exit || }}}

" {{{ || Terminal || ---
tnoremap <M-c> <C-\><C-n>
if &shell =~ 'cmd'
  tnoremap <C-p> <Up>
  tnoremap <C-n> <Down>
  tnoremap <C-f> <Right>
  tnoremap <C-b> <Left>
  tnoremap <M-f> <C-Right>
  tnoremap <M-b> <C-Left>
  tnoremap <C-a> <Home>
  tnoremap <C-e> <End>
  tnoremap <C-d> <Del>
  tnoremap <C-u> <Esc>
endif

" --- || Terminal || }}}

" {{{ || Others || ---
map <S-Space> <Space>
nnoremap <C-s> :update<CR>
if has('gui')
  nnoremap <F3> :source $MYVIMRC<CR>:source $MYGVIMRC<CR>
else
  nnoremap <F3> :source $MYVIMRC<CR>
endif
nnoremap <Leader><F3> :tabnew $MYVIMRC<CR>
nnoremap [Chief]<F3> :call OpenFtplugins(&ft)<CR>
nnoremap [Captain]<F3> :SetFt<CR>
nnoremap Q gQ
nnoremap <M-c> <Cmd>mode<CR>
" [insert/command mode]
cnoremap <C-j> <Tab>
cnoremap <expr> <C-p> wildmenumode() ? "\<C-p>" : "\<Up>"
cnoremap <expr> <C-n> wildmenumode() ? "\<C-n>" : "\<Down>"
cnoremap <M-@> <Home>let @" = '<End>'
" retry triggering abbreviation
inoremap <C-g><C-]> <Esc>ciw<C-r>"<C-]>
lua << EOF
  local wk = require("which-key")
  wk.register({
    ["_"] = {
      name = "nice ones",
      c = { "<Cmd>lcd %:p:h | echo 'lcd -> ' . expand('%:p:h')<CR>", "lcd to the file's dir" },
      d = { "<Cmd>echo 'current dir: ' . getcwd()<CR>", "Print current dir" },
      p = { "<Cmd>echo 'filepath: ' . expand('%:p')<CR>", "Print current file's absolute path" },
    },
  })
EOF
" --- || Others || }}}

" --- || key mapping || }}}

" {{{ || functions || ---
" https://stackoverflow.com/questions/24027506/get-a-vim-scripts-snr
" Return the <SNR> of a script.
" Args:
"   script_name : (str) The name of a sourced script.
" Return:
"   (int) The <SNR> of the script; if the script isn't found, -1.
func! GetScriptNumber(script_name)
  redir => scriptnames
  silent! scriptnames
  redir END

  for script in split(l:scriptnames, "\n")
    if l:script =~ a:script_name
      return str2nr(split(l:script, ":")[0])
    endif
  endfor

  return -1
endfunc
" --- || functions || }}}

" {{{ || plugin mapping and option || ---

" {{{ || which-key || ---
highlight WhichKeyFloat ctermbg=237
highlight link WhichKey Type
highlight link WhichKeyDesc Type
lua << EOF
  require("which-key").setup {
    plugins = {
      presets = {
        operators = false, -- adds help for operators like d, y, ...
      },
    },
    operators = {
      d = "Delete",
      c = "Change",
      y = "Yank (copy)",
      ["g~"] = "Toggle case",
      ["gu"] = "Lowercase",
      ["gU"] = "Uppercase",
      [">"] = "Indent right",
      ["<lt>"] = "Indent left",
      ["zf"] = "Create fold",
      ["!"] = "Filter though external program",
      -- ["v"] = "Visual Character Mode",
      gc = "Comments"
    },
  window = {
      border = "none", -- none, single, double, shadow
      position = "bottom", -- bottom, top
      margin = { 0, 0, 0, 0 }, -- extra window margin [top, right, bottom, left]
      padding = { 1, 2, 1, 2 }, -- extra window padding [top, right, bottom, left]
      winblend = 0 -- value between 0-100 0 for fully opaque and 100 for fully transparent
    },
    layout = {
      height = { min = 4, max = 25 }, -- min and max height of the columns
      width = { min = 20, max = 50 }, -- min and max width of the columns
      spacing = 5, -- spacing between columns
      align = "left", -- align columns left, center or right
    },
  }
EOF
" --- || which-key || }}}

" {{{ || termdebug || ---
let g:termdebug_wide = 1

lua << EOF
  local wk = require("which-key")
  wk.register({
    g = {
      name = "termdebug",
      a = { "<Cmd>Arguments<CR>", "Set arguments to the next :Run" },
      b = { "<Cmd>Break<CR>", "Add breakpoint" },
      B = { "<Cmd>Clear<CR>", "Clear breakpoint" },
      c = { "<Cmd>Continue<CR>", "Continue" },
      f = { "<Cmd>Finish<CR>", "Finish" },
      g = { "<Cmd>GdbIns<CR>", "Jump to gbd" },
      i = { "<Cmd>Step<CR>", "Step in" },
      n = { "<Cmd>Over<CR>", "Step over" },
      o = { "<Cmd>Program<CR>", "Jump to program" },
      r = { "<Cmd>Run<CR>", "Run the program with arguments" },
      s = { "<Cmd>Source<CR>", "Jump to source" },
      x = { "<Cmd>Stop<CR>", "Stop (interrupt the program)" },
    },
  }, { prefix = vim.g.chief_key })
EOF

function! GdbIns() abort
  Gdb
  startinsert
endfunction
command! -buffer GdbIns call GdbIns()
" --- || termdebug || }}}

" {{{ || vim-fugitive || ---
if exists('g:plugs["vim-fugitive"]')
  " let g:fugitive_no_maps = 1 " To prevent <C-n/p> to be mapped
  cnoreabbrev gs Git
  cnoreabbrev gl Git log
  cnoreabbrev glg vertical sbuffer <Bar> Gllog
  cnoreabbrev gd Gvdiffsplit
  cnoreabbrev gp Git push
lua << EOF
  local wk = require("which-key")
  wk.register({
    v = {
      name = "VCS",
      -- fugitive
      s = { "<Cmd>tab Git<CR>", "vim-fugitive" },
      lt = { "<Cmd>tab Git log<CR>", "git log [tab]" },
      lv = { "<Cmd>vertical Git log<CR>", "git log [vert]" },
      B = { "<Cmd>Git blame<CR>", "git blame entire file" },
      -- gitgutter
      h = {
    name = "GitGutter",
        h = { "<Cmd>GitGutter<CR>", "GitGutter Reload"},
        p = { "<Plug>(GitGutterPreviewHunk)", "GitGutter Preview Hunk" },
        s = { "<Plug>(GitGutterStageHunk)", "GitGutter Stage Hunk" },
        u = { "<Plug>(GitGutterUndoHunk)", "GitGutter Undo Hunk" },
      },
      -- git-blame
      b = { "<Cmd>GitBlame<CR>", "git blame current line" },
    },
  }, { prefix = "<Leader>" })
EOF
endif
" --- || vim-fugitive || }}}

" {{{ || vim-gitgutter || ---
if exists('g:plugs["vim-gitgutter"]')
  let g:gitgutter_preview_win_floating = 0
endif
" --- || vim-gitgutter || }}}

" {{{ || git-blame.vim || ---
if exists('g:plugs["git-blame.vim"]')
endif
" --- || git-blame.vim || }}}

" {{{ || airline || ---
if !exists('g:plugs["vim-airline"]')
  set statusline=(%{winnr()})       " window number
  set statusline+=%f            " relative path
  set statusline+=[%{strlen(&fenc)?&fenc:'none'},%{&ff}]  " [file encoding,file format]
  set statusline+=%y%r%m          " file type; readonly flag; modified flag
  set statusline+=%=%c,%l/%L%6.6P     " right align; current column,line/total line; percentage with fixed width of 6 chars
endif
if exists('g:plugs["vim-airline"]')
  set noshowmode
  let g:airline_theme='cool'
  let g:airline_section_b = ''
  let g:airline_section_c = '(%{winnr()}) %<%{fnamemodify(getcwd(), ":~")} | %{expand("%")}%m %#__accent_red#%{airline#util#wrap(airline#parts#readonly(),0)}%#__restore__#'
endif
" --- || airline || }}}

" {{{ || nvim-miniyank || ---
if exists('g:plugs["nvim-miniyank"]')
  let g:miniyank_maxitems = 20
  map p <Plug>(miniyank-autoput)
  map P <Plug>(miniyank-autoPut)
  map <M-p> <Plug>(miniyank-cycle)
  map <M-P> <Plug>(miniyank-cycleback)
endif
" --- || nvim-miniyank || }}}

" {{{ || indentLine || ---
let g:indentLine_setConceal = 0
let g:indentLine_fileTypeExclude = ['markdown', 'vimwiki', 'json', 'nerdtree', 'man']
let g:indentLine_bufTypeExclude = ['help', 'terminal']
" --- || indentLine || }}}

" {{{ || NERDCommenter || ---
if exists('g:plugs["nerdcommenter"]')
  let g:NERDSpaceDelims = 1       " Add spaces after comment delimiters
  let g:NERDDefaultAlign = 'left'
  nnoremap <silent> <C-\> :call nerdcommenter#Comment("n","toggle")<CR>
  vnoremap <silent> <C-\> :call nerdcommenter#Comment("n","toggle")<CR>
  inoremap <silent> <C-\> <C-o>:call nerdcommenter#Comment("n","toggle")<CR>
endif
" --- || NERDCommenter || }}}

" {{{ || NERDTree || ---
if exists('g:plugs["nerdtree"]')
  let g:NERDTreeShowLineNumbers = 1
  let g:NERDTreeSortHiddenFirst = 1
  let g:NERDTreeShowHidden=1
  let g:NERDTreeQuitOnOpen=3
  let g:NERDTreeUseTCD=1
  let g:NERDTreeWinSize = 40
  let g:NERDTreeCustomOpenArgs={
        \ 'file': {'reuse': 'all', 'where': 't', 'keepopen': 1, 'stay': 1},
        \ 'dir': {'reuse': 'all', 'where': 't', 'keepopen': 1, 'stay': 1}
        \ }
  " call NERDTreeAddKeyMap({
  "     \ 'key': 'J',
  "     \ 'callback': {-> feedkeys('gt')},
  "     \ 'quickhelpText': 'use my own J mapping',
  "     \ 'scope': 'Node',
  "     \ 'override': 1})
  " call NERDTreeAddKeyMap({
  "     \ 'key': 'K',
  "     \ 'callback': {-> feedkeys('gt')},
  "     \ 'quickhelpText': 'use my own K mapping',
  "     \ 'scope': 'Node',
  "     \ 'override': 1})
  " NERDTreeAddKeyMap() overrides keybinds only with the same scope
  " (J/K are 'Node' scope)
  " So use autocmd to override no matter what scope default mapping is in
  " <buffer> is necessary to override
  " augroup nerd_tree
  "     autocmd!
  "     autocmd FileType nerdtree nnoremap <buffer> J gt
  "     autocmd FileType nerdtree nnoremap <buffer> K gT
  " augroup END
  function! s:InitNERDTreeCmds()
    let l:nerd_tree_cmds = {
          \ 'n': runcmds#init#MakeCmdInfo('NERDTree', v:false, [], v:true),
          \ 'N': runcmds#init#MakeCmdInfo('NERDTree %:h'),
          \ 't': runcmds#init#MakeCmdInfo('NERDTreeToggle'),
          \ 'o': runcmds#init#MakeCmdInfo('NERDTreeFocus'),
          \ 'v': runcmds#init#MakeCmdInfo('NERDTreeVCS'),
          \ 'b': runcmds#init#MakeCmdInfo('NERDTreeFromBookmark', v:false, [], v:true),
          \ 'f': runcmds#init#MakeCmdInfo('NERDTreeFind'),
          \ 'c': runcmds#init#MakeCmdInfo('NERDTreeCWD'),
          \ 'r': runcmds#init#MakeCmdInfo('NERDTreeRefreshRoot'),
          \ }
    function! s:NERDTreeCmds() closure
      return l:nerd_tree_cmds
    endfunction
  endfunction
  function! s:InitNERDTreeFlagDict()
    let l:nerd_tree_flags = runcmds#init#MakeFlagDict(';', "\<Space>")
    function! s:NERDTreeFlags() closure
      return l:nerd_tree_flags
    endfunction
  endfunction
  call s:InitNERDTreeCmds()
  call s:InitNERDTreeFlagDict()
  nnoremap <expr> [Chief]t runcmds#base#RunCmds("NERDTree", <SID>NERDTreeCmds(), <SID>NERDTreeFlags())
endif
" --- || NERDTree || }}}

" {{{ || ranger.vim || ---
if exists('g:plugs["ranger.vim"]')
  let g:NERDTreeHijackNetrw = 0 " this is NERDTree setting
  let g:ranger_map_keys = 0
  let g:ranger_replace_netrw = 1
endif
lua << EOF
  local wk = require("which-key")
  wk.register({
    e = {
      name = "Ranger", -- optional group name
      t = { "<Cmd>tab split | Ranger<CR>", "Ranger [tab]" },
      v = { "<Cmd>call OpenRangerIn('%:p:h', 'vnew ')<CR>", "Ranger [vert]" },
      w = { "<Cmd>call OpenRangerIn('%:p:h', 'new ')<CR>", "Ranger [horz]" },
    },
  }, { prefix = vim.g.chief_key })
EOF
" --- || ranger.vim || }}}"

" {{{ || bclose.vim || ---
if exists('g:plugs["bclose.vim"]')
  let g:bclose_no_plugin_maps = v:true
endif
" --- || bclose.vim || }}}"

" {{{ || tagbar || ---
if exists('g:plugs["tagbar"]')
  nnoremap <Leader>o :TagbarToggle<CR>
  nnoremap <Leader>O :TagbarOpen fj<CR>
endif
" --- || tagbar || }}}

" {{{ || vim-surround || ---
if exists('g:plugs["vim-surround"]')
  " set characters and correspondng wrappers
  " value for variable have to be surrounded by "", not ''
  " pre-defined mappings that are useful are:
  " t: "<[tag]>\r</[tag]>" <- [tag] will be replaced by user input
  " f: "[function](\r)" <- [function] will be replaced by user input
  let g:surround_no_mappings = 1
  nmap dr  <Plug>Dsurround
  nmap cr  <Plug>Csurround
  nmap cR  <Plug>CSurround
  nmap yr  <Plug>Ysurround
  nmap yR  <Plug>YSurround
  nmap yrr <Plug>Yssurround
  nmap yRR <Plug>YSsurround
  xmap R   <Plug>VSurround
  xmap gR  <Plug>VgSurround
  let g:surround_{char2nr('d')} = "${\r}"
  let g:surround_{char2nr('D')} = "\"${\r}\""
  let g:surround_{char2nr('s')} = "$(\r)"
  let g:surround_{char2nr('S')} = "\"$(\r)\""
endif
" --- || vim-surround || }}}

" {{{ || auto-pairs || ---
if exists('g:plugs["auto-pairs"]')
  let g:AutoPairsShortcutToggle = ''
  let g:AutoPairsShortcutFastWrap = '<M-p>'
  let g:AutoPairsShortcutJump = '<M-n>'
  let g:AutoPairsShortcutBackInsert = '<M-\>'
  let g:AutoPairsMapSpace = 0   " Enabling this maps <Space> to <C-]><C-R>=... and <C-]> is unwanted
  let g:AutoPairsMultilineClose = 0
  inoremap <silent> <Space> <C-g>u<C-r>=AutoPairsSpace()<CR>
endif
" --- || auto-pairs || }}}

" {{{ || easy-motion || ---
if exists('g:plugs["vim-easymotion"]')
  " this option unmap all easymotion-prefix including user defined ones
  " let g:EasyMotion_do_mapping = 0
  let g:EasyMotion_smartcase = 1
  let g:EasyMotion_use_upper = 1
  let g:EasyMotion_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ;'
  let g:EasyMotion_enter_jump_first = 1
  let g:EasyMotion_space_jump_first = 1
  let g:EasyMotion_off_screen_search = 1
  " this disables highlighting by `n` command, but you need easymotion-next/prev to move around
  let g:EasyMotion_add_search_history = 1
  let g:EasyMotion_startofline = 0
  " mapping easymotion-prefix prevents <Leader><Leader> from being mapped
  " map <S-F12> <Plug>(easymotion-prefix)
  map s <Plug>(easymotion-prefix)
  map f <Plug>(easymotion-fl)
  map F <Plug>(easymotion-Fl)
  map t <Plug>(easymotion-tl)
  map T <Plug>(easymotion-Tl)
  map s/ <Plug>(easymotion-sn)
  map s. <Plug>(easymotion-repeat)
  map <Bslash> <Plug>(easymotion-next)
  map <Bar> <Plug>(easymotion-prev)
endif
" --- || easy-motion || }}}

" {{{ || vim-indent-object || ---
if exists('g:plugs["vim-indent-object"]')
  nmap yx yaI']p
endif
" --- || vim-indent-object || }}}

" {{{ || vim-indentwise || ---
if exists('g:plugs["vim-indentwise"]')
  " reference: https://github.com/jeetsukumaran/vim-indentwise/issues/12#issuecomment-591092209
  function! s:SetupVimIndentwise() abort
    let l:vim_indentwise_snr = GetScriptNumber("vim-indentwise")
    let l:move_to_indent_depth_ref = printf('<SNR>%d_move_to_indent_depth(1, "==", 0, "o")', l:vim_indentwise_snr)
    function! s:MoveToIndentDepthRef() closure
      return l:move_to_indent_depth_ref
    endfunction
  endfunction
  call s:SetupVimIndentwise()
  onoremap <Plug>(IndentWisePreviousEqualIndent) V:<C-U>call eval(<SID>MoveToIndentDepthRef())<CR>
  onoremap <Plug>(IndentWiseNextEqualIndent)     V:<C-U>call eval(<SID>MoveToIndentDepthRef())<CR>
  map { <Plug>(IndentWisePreviousEqualIndent)
  map } <Plug>(IndentWiseNextEqualIndent)
endif
" --- || vim-indentwise || }}}

" {{{ || CamelCaseMotion || ---
if exists('g:plugs["CamelCaseMotion"]')
  map <silent> <M-w> <Plug>CamelCaseMotion_w
  map <silent> <M-b> <Plug>CamelCaseMotion_b
  omap <silent> im <Plug>CamelCaseMotion_ie
  xmap <silent> im <Plug>CamelCaseMotion_ie
  omap <silent> am <Plug>CamelCaseMotion_iw
  xmap <silent> am <Plug>CamelCaseMotion_iw
endif
" --- || CamelCaseMotion || }}}

" {{{ || fzf.vim || ---
if exists('g:plugs["fzf.vim"]')
  let g:fzf_command_prefix = 'Fzf'
    let g:fzf_buffers_jump = 1
  imap <c-x><c-k> <plug>(fzf-complete-word)
  imap <c-x><c-f> <plug>(fzf-complete-path)
  imap <c-x><c-l> <plug>(fzf-complete-line)

  function! s:InitFzfCmds()
    let l:fzf_cmds = {
          \ 'f': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Files'),
          \ 'F': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Files %:h'),
          \ 'g': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'GFiles'),
          \ 'G': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'GFiles?'),
          \ 'b': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Buffers'),
          \ 'r': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Rg', v:false, [], v:true),
          \ 'L': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Lines'),
          \ 'l': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'BLines'),
          \ 'T': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Tags'),
          \ 't': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'BTags'),
          \ 'k': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Marks'),
          \ 'w': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Windows'),
          \ 'y': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'History'),
          \ ':': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'History:'),
          \ '/': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'History/'),
          \ 's': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Snippets'),
          \ 'C': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Commits'),
          \ 'c': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'BCommits'),
          \ 'd': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Commands'),
          \ 'm': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Maps'),
          \ 'h': runcmds#init#MakeCmdInfo(g:fzf_command_prefix . 'Helptags'),
          \ }
    function! s:FzfCmds() closure
      return l:fzf_cmds
    endfunction
  endfunction
  function! s:InitFzfFlagDict()
    let l:fzf_flags = runcmds#init#MakeFlagDict(';', "\<Space>")
    function! s:FzfFlags() closure
      return l:fzf_flags
    endfunction
  endfunction
  call s:InitFzfCmds()
  call s:InitFzfFlagDict()
  nnoremap <expr> [Chief]f runcmds#base#RunCmds("FZF", <SID>FzfCmds(), <SID>FzfFlags())
endif
" --- || fzf.vim || }}}

" {{{ || ctrlp || ---
if exists('g:plugs["ctrlp.vim"]')
  " for now, just disable the default mapping to prevent from <C-p> to be overridden
  let g:ctrlp_map = '<F13>'
endif
" --- || ctrlp || }}}

" {{{ || vim-projectionist || ---
let g:projectionist_heuristics = {
      \   "src/main/java/|src/test/java/": {
      \     "src/main/java/*.java": {
      \       "alternate": "src/test/java/{}Test.java",
      \       "type": "main"
      \     },
      \     "src/test/java/*.java": {
      \       "alternate": "src/main/java/{}.java",
      \       "type": "test"
      \     },
      \     "src/main/resources/*": {
      \       "type": "resource"
      \     },
      \     "src/test/resources/*": {
      \       "type": "tresource"
      \     }
      \   }
      \ }
" --- || vim-projectionist || }}}

" {{{ || UltiSnips || ---
if exists('g:plugs["ultisnips"]')
  let g:UltiSnipsExpandTrigger="<C-]>"
  let g:UltiSnipsJumpForwardTrigger="<C-s>"
  let g:UltiSnipsJumpBackwardTrigger="<M-s>"
  cnoreabbrev us call UltiSnips#
endif
" --- || UltiSnips || }}}

" {{{ || neosnippet.vim || ---
if exists('g:plugs["neosnippet.vim"]')
  let g:neosnippet#enable_snipmate_compatibility = 1
  let g:neosnippet#snippets_directory = '~/toybox/vim/rtp/neoppets/'
  imap <C-]> <Plug>(neosnippet_expand)
  imap <C-s> <Plug>(neosnippet_jump)
  smap <C-s> <Plug>(neosnippet_jump)
  xmap <C-]> <Plug>(neosnippet_expand_target)
endif
" --- || neosnippet.vim || }}}

" {{{ || deoppet.nvim || ---
if exists('g:plugs["deoppet.nvim"]')
  imap <C-]>  <Plug>(deoppet_expand)
  imap <C-s>  <Plug>(deoppet_jump_forward)
  imap <M-s>  <Plug>(deoppet_jump_backward)
  xmap <C-l>  <Plug>(deoppet_select_text)
  xmap <C-x>  <Plug>(deoppet_cut_text)
  call deoppet#initialize()
  let s:snippetDirs = []
  call extend(s:snippetDirs, globpath(&runtimepath, 'snippets', 1, 1))
  call extend(s:snippetDirs, globpath(&runtimepath, 'UltiSnips', 1, 1))
  call extend(s:snippetDirs, globpath(&runtimepath, 'neosnippets', 1, 1))
  echom s:snippetDirs
  call deoppet#custom#option('snippets', map(s:snippetDirs, { _, val -> { 'path': val } }))
endif
" --- || deoppet.nvim || }}}

" {{{ || LanguageClient-neovim || ---
if exists('g:plugs["LanguageClient-neovim"]')
  set hidden
  let g:LanguageClient_changeThrottle = 0.5
  let g:LanguageClient_diagnosticsList = "Location"
  let g:LanguageClient_hoverMarginSize = 2
  let g:LanguageClient_preferredMarkupKind = ['markdown', 'plaintext']
  let g:LanguageClient_useVirtualText = 'Diagnostics'
  let g:LanguageClient_completionPreferTextEdit = 1
  let g:LanguageClient_floatingHoverHighlight = 'Normal:Normal'
  let g:LanguageClient_serverCommands = {
        \ 'go': [$GOPATH . '/bin/gopls'],
        \ 'java': [$HOME.'/toybox/vim/helper/java-lsp.sh', '-data', getcwd()],
        \ 'javascript': ['typescript-language-server', '--stdio'],
        \ 'php': [s:plugin_dir . '/phpactor/bin/phpactor', 'language-server'],
        \ 'python': [executable('/usr/local/bin/pyls') ? '/usr/local/bin/pyls' : $HOME.'/.local/bin/pyls'],
        \ 'rust': {
        \   'name': 'rust-analyzer',
        \   'command': ['rustup', 'run', 'nightly', 'rust-analyzer'],
        \   'initializationOptions': {
        \     'completion': {
        \       'addCallParenthesis': v:false,
        \       'addCallArgumentSnippets': v:false,
        \     },
        \   },
        \ },
        \ }
        " \ 'rust': ['rustup', 'run', !empty($RUST_VERSION) ? $RUST_VERSION : 'stable', 'rls'],
  let g:LanguageClient_loggingFile = expand('~/.local/share/nvim/LanguageClient.log')
  let g:LanguageClient_serverStderr = expand('~/.local/share/nvim/LanguageServer.log')

  let s:def_cmds = {
        \ 'a': runcmds#init#MakeCmdInfo('AV'),
        \ 'd': runcmds#init#MakeCmdInfo('LcnHover'),
        \ 'D': runcmds#init#MakeCmdInfo('LcnHoverClose'),
        \ 'f': runcmds#init#MakeCmdInfo('LcnFormat'),
        \ 'h': runcmds#init#MakeCmdInfo('LcnDocHighlight'),
        \ 'H': runcmds#init#MakeCmdInfo('LcnDocHighlightClear'),
        \ 'n': runcmds#init#MakeCmdInfo('LcnRename'),
        \ 'o': runcmds#init#MakeCmdInfo('LcnDocSymbol'),
        \ 'R': runcmds#init#MakeCmdInfo('LcnReference'),
        \ '0': runcmds#init#MakeCmdInfo('LcnCodeAction'),
        \ }
  function! DefaultCmds()
    return copy(s:def_cmds)
  endfunction

  command! LcnCodeAction call LanguageClient#textDocument_codeAction()
  command! LcnFormat call LanguageClient#textDocument_formatting()
  command! LcnDocHighlight call LanguageClient#textDocument_documentHighlight()
  command! LcnDocHighlightClear call LanguageClient#clearDocumentHighlight()
  command! LcnDocSymbol call LanguageClient#textDocument_documentSymbol()
  command! LcnHover call LanguageClient#textDocument_hover()
  command! LcnHoverClose call LanguageClient#closeFloatingHover()
  command! LcnRename call LanguageClient#textDocument_rename()
  command! LcnReference call LanguageClient#textDocument_references()

lua << EOF
  local wk = require("which-key")
  wk.register({
    ["<C-]>"] = { "<Cmd>call LanguageClient#textDocument_definition()<CR>", "Definition" },
    ["g<C-]>"] = { "<Cmd>call LanguageClient#textDocument_implementation()<CR>", "Implementation" },
    ["<C-w>"] = {
      ["<C-]>"] = { "<Cmd>split | call LanguageClient#textDocument_definition()<CR>", "Definition [horz]" },
      ["<C-g><C-]>"] = { "<Cmd>split | call LanguageClient#textDocument_implementation()<CR>", "Implementation [horz]" },
    },
    ["[Vert]"] = {
      ["<C-]>"] = { "<Cmd>vertical split | call LanguageClient#textDocument_definition()<CR>", "Definition [vert]" },
      ["<C-g><C-]>"] = { "<Cmd>vertical split | call LanguageClient#textDocument_implementation()<CR>", "Implementation [vert]" },
    },
    ["<C-t>"] = {
      ["<C-]>"] = { "<Cmd>tab split | call LanguageClient#textDocument_definition()<CR>", "Definition [tab]" },
      ["<C-g><C-]>"] = { "<Cmd>tab split | call LanguageClient#textDocument_implementation()<CR>", "Implementation [tab]" },
    },
  })
EOF
endif
" --- || LanguageClient-neovim || }}}

" {{{ || neomake || ---
if exists('g:plugs["neomake"]')
  try
    call neomake#configure#automake('w')
  catch /^Vim\%((\a\+)\)\=:E117/
    " The function does not exist. Ignore it.
  endtry
  let g:neomake_open_list = 2
endif
" --- || neomake || }}}

" {{{ || deoplete || ---
if exists('g:plugs["deoplete.nvim"]')
  let g:deoplete#enable_at_startup = 1
  call deoplete#custom#source('_', 'smart_case', v:true)
  if has('win32')
    " cmd is "python.exe" so deoplete (yarp?) cannot find it by default
    let g:python3_host_prog="python"
  endif
  inoremap <silent> <expr> <C-i> pumvisible() ? "\<C-n>" : deoplete#complete()
endif
" --- || deoplete || }}}

" {{{ || ddc || ---
if exists('g:plugs["ddc.vim"]')
  inoremap <silent> <expr> <C-i> pumvisible() ? "\<C-n>" : ddc#map#complete()
  call ddc#custom#patch_global('sources', ['around', 'nvim-lsp'])
  call ddc#custom#patch_global('sourceOptions', {
        \ '_': { 'matchers': ['matcher_head'] },
        \ 'nvim-lsp': {
          \   'mark': 'L',
          \   'forceCompletionPattern': '\.\w*|:\w*|->\w*' },
          \ })
endif
" --- || ddc || }}}

" {{{ || echodoc.vim || ---
let g:echodoc#enable_at_startup = 1
" floating breads UltiSnips' function to jump between markers
" let g:echodoc#type = 'floating'
" highlight link EchoDocFloat Pmenu
" --- || echodoc.vim || }}}

" {{{ || project.nvim || ---
lua << EOF
  require("project_nvim").setup {
    show_hidden = false,
  patterns = { "Cargo.toml", ".git", "_darcs", ".hg", ".bzr", ".svn", "Makefile", "package.json" },
  }
EOF
" --- || project.nvim || }}}

" {{{ || vim-abolish || ---
let g:abolish_no_mappings = 1
" --- || vim-abolish || }}}

" {{{ || vim-test || ---
if has('nvim')
  " By default, tab is opened left to the current tab, and that makes
  " closing the test tab focus the tab left to the original tab.
  " The below configuration opens the test right to the original tab.
  let test#neovim#term_position = "tab"
  let test#strategy = 'neovim'
endif
" --- || vim-test || }}}

" {{{ || stephpy/vim-php-cs-fixer || ---
let g:php_cs_fixer_enable_default_mapping = 0
" --- || stephpy/vim-php-cs-fixer || }}}

" {{{ || vim-laravel || ---
if exists('g:plugs["vim-laravel"]')
  augroup init_laravel
  autocmd!
  autocmd User ProjectionistDetect
      \ if exists('b:laravel_root') |
      \   call projectionist#append(b:laravel_root, {
      \     'storage/logs/*.log': { 'type': 'log' },
      \     'storage/logs/laravel.log': { 'type': 'log' },
      \     'app/Http/Controllers/*.php': {
      \       'alternate': 'tests/Unit/Controllers/{}Test.php',
      \     },
      \     'app/Models/*.php': {
      \       'alternate': 'tests/Unit/Models/{}Test.php',
      \     }
      \   }) |
      \ endif
  augroup END
endif
" --- || vim-laravel || }}}

" {{{ || vimwiki || ---
let g:vimwiki_key_mappings = {
      \ 'all_maps': 0,
      \ 'global': 0,
      \ 'headers': 1,
      \ 'text_objs': 0,
      \ 'table_format': 0,
      \ 'table_mappings': 0,
      \ 'lists': 0,
      \ 'links': 0,
      \ 'html': 0,
      \ 'mouse': 0,
      \ }
" let g:vimwiki_folding = 'list'
" --- || vimwiki || }}}

" --- || plugin mapping and option || }}}

" {{{ || abbreviation || ---
cnoreabbrev ehco echo
cnoreabbrev tn tabnew
cnoreabbrev tm TabnewMulti
cnoreabbrev tnro tabnew <Bar> view
cnoreabbrev spro split <Bar> view
cnoreabbrev vsro vsplit <Bar> view
cnoreabbrev ts tab split
cnoreabbrev vb vertical sbuffer
cnoreabbrev tb tab sbuffer
cnoreabbrev vh vertical help <Bar> execute "normal! \<lt>C-w>80\<Bar>"<C-Left><C-Left><C-Left><C-Left><Left>
cnoreabbrev th tab help
cnoreabbrev bold browse oldfiles
cnoreabbrev st new <Bar> terminal
cnoreabbrev vt vnew <Bar> terminal
cnoreabbrev tt tabnew <Bar> terminal
" --- || abbreviation || }}}

" {{{ || functions || ---
" move back cursor before a command is executed
" offset moves down and right n lines/columns to the original position
function! Preserve(command, linoff, coloff)
  let l = line(".") + a:linoff
  let c = col(".") + a:coloff
  echo a:command
  execute a:command
  call cursor(l, c)
endfunction

fun s:RedrawCancel()
  mode
  echo 'Cancelled'
  return 0
endf

" getchar() with Ctrl+C to cancel
" This returns numeric 0 if interrupted, so the value is compared using 'is'
function! GetChar(escape_means_cancel)
  try
    call inputsave()
    let l:char = nr2char(getchar())
    if a:escape_means_cancel && l:char == "\<Esc>"
      return s:RedrawCancel()
    endif
    return l:char
  catch /^Vim:Interrupt$/
    return s:RedrawCancel()
  finally
    call inputrestore()
  endtry
endfunction

" input() with Ctrl+C to cancel
" This returns numeric 0 if interrupted, so the value is compared using 'is'
function! Input(empty_means_cancel, ...)
  let l:opts = {}
  if a:0 > 0
    if type(a:1) == v:t_dict
      let l:opts = a:1
    else
      let l:opts['prompt'] = get(a:000, 0, '')
      let l:opts['default'] = get(a:000, 1, '')
      if a:0 >= 3
        let l:opts['completion'] = a:3
      endif
    endif
  endif
  try
    call inputsave()
    let l:input = input(l:opts)
    if a:empty_means_cancel && l:input is ''
      return s:RedrawCancel()
    endif
    return l:input
  catch /^Vim:Interrupt$/
    return s:RedrawCancel()
  finally
    call inputrestore()
  endtry
endfunction

" add elements only if the specified list does not contain the same value
function! AddUniq(list, elm)
  if index(a:list, a:elm) == -1
    call add(a:list, a:elm)
  endif
endfunction

function! IsCtrlAlpha(char)
  let l:char_num = char2nr(a:char)
  return char2nr("\<C-a>") <= l:char_num && l:char_num <= char2nr("\<C-z>")
endfunction

" @case: 1 for lowercase, 2 for uppercase
function! ConvertCtrlCharToNormal(char, case)
  const [l:lowercase, l:uppercase] = [1, 2]
  const l:deltas = {
        \ l:lowercase: char2nr('a') - char2nr("\<C-a>"),
        \ l:uppercase: char2nr('A') - char2nr("\<C-a>"),
        \}

  let l:char_num = char2nr(a:char)
  if !IsCtrlAlpha(a:char)
    echoerr printf('Invalid argument: %s is not ctrl-{alphabet}', a:char)
    return
  endif

  let l:delta = get(l:deltas, a:case, '')
  if l:delta is ''
    echoerr printf('Invalid argument: case must be either %s', [l:lowercase, l:uppercase])
    return
  endif

  return nr2char(l:char_num + l:delta)
endfunction

function! Expander()
  echohl Identifier
  echo 'Ctrl+: [b]asename, [s]implename, [d]irname, [f]ullname, [p]wd'
  echohl NONE
  let l:char = nr2char(getchar())
  if l:char ==? "b" || l:char ==? "\<C-b>"
    let l:cmd = "\<C-r>=expand('%:t')\<CR>"
  elseif l:char ==? "s" || l:char ==? "\<C-s>"
    let l:cmd = "\<C-r>=expand('%:t:r')\<CR>"
  elseif l:char ==? "d" || l:char ==? "\<C-d>"
    let l:cmd = "\<C-r>=expand('%:p:h')\<CR>"
  elseif l:char ==? "f" || l:char ==? "\<C-f>"
    let l:cmd = "\<C-r>=expand('%:p')\<CR>"
  elseif l:char ==? "p" || l:char ==? "\<C-p>"
    let l:cmd = "\<C-r>=getcwd()\<CR>"
  else
    echohl WarningMsg | echo 'Not an available option: '.l:char | echohl NONE
    sleep 1
    " return space and backspace to clean up the msg in command line
    let l:cmd = "\<Space>\<BS>"
  endif

  return l:cmd
endfunction

function! SelectBtwCols(sln, spos, eln, epos)
  " NOTE: Use cursor() instead of '|' command
  " searchpairpos() reterns 'n' as in nth char rather than column number.
  " '|' goes to column number, so if the line is indented with tab, '|' misbehaves.
  " since tab is single character but takes up &shiftwidth columns
  " execute 'normal! '.l:spos.'|v'.l:epos.'|'
  silent execute printf("normal! :call cursor(%s, %s)\<CR>v:call cursor(%s, %s)\<CR>v`<", a:sln, a:spos, a:eln, a:epos)
endf

function! SelectPair(start, middle, end, include)
  " NOTE: searchpairpos works a little weird as illustrated below
  " With 'c' option, if the cursor is on the first char of 'start' string (with 'b' option, last char of 'end' string),
  " searchpairpos() cannot find the match.
  let [l:sln, l:spos] = searchpairpos(a:start, a:middle, a:end, 'bc')
  let [l:eln, l:epos] = searchpairpos(a:start, a:middle, a:end)
  if l:spos == 0 || l:epos == 0
    " no match was found
    return
  endif
  if !a:include
    let l:spos = l:spos + len(a:start)
    let l:epos = l:epos - len(a:end)
  endif
  call SelectBtwCols(l:sln, l:spos, l:eln, l:epos)
endfunction

" Select either function/method call, object property, or struct (including object itself)
function! SelectElement()
  let l:elemRegexp = '[A-Za-z0-9_.]\+[({]'
  let [l:sln, l:spos] = searchpos(l:elemRegexp, 'bc')
  let [l:eln, l:epos] = searchpos(l:elemRegexp, 'e')
  let l:lastchar = getline(l:eln)[l:epos-1]
  if l:lastchar =~ '[({]'
    let l:start = l:lastchar
    let l:end = ')'
    if l:lastchar == '{'
      let l:end = '}'
    endif
    let [l:eln, l:epos] = searchpairpos(l:start, '', l:end)
  endif
  call SelectBtwCols(l:sln, l:spos, l:eln, l:epos)
endf

function! SetTitle(title)
  let l:escapedTitle = escape(a:title, ' \')
  execute 'set titlestring=' . l:escapedTitle
  set title
endfunction
command! -nargs=1 SetTitle :call SetTitle(<q-args>)

" get full path of all window of all tab, then save them into @* or @"
" depending on the availability of 'clipboard' option
function! ClipAllWinTabPaths()
  let l:lasttabnr = tabpagenr()

  if has('clipboard')
    let l:register = '*'
  else
    let l:register = '"'
  endif

  let l:patharr = []
  tabdo windo call AddUniq(l:patharr, expand('%:p'))
  call setreg(l:register, join(l:patharr, "\n"))

  execute "tabnext " . l:lasttabnr

  if !has('clipboard')
    $ tabnew
    put
    global/^$/delete
  endif
endfunction
command! ClipAllWinTabPaths :call ClipAllWinTabPaths()

" Open files on each line one file in one tab
function! OpenFileOnEachLine() range
  " silent global/^$/delete
  " let l:linecnt = 1
  let l:cmd = ""
  " let l:totallinenum = line("$")
  " call cursor(1, 1)
  for l:linenum in range(a:firstline, a:lastline)
    call cursor(l:linenum, 1)
    let l:path = expand("<cfile>")
    if !filereadable(l:path)
      continue
    endif
    let l:cmd .= "tabnew ".l:path." \<Bar> "
  endfor
  " while l:linecnt <= l:totallinenum
  "     call cursor(l:linecnt, 1)
  "     let l:cmd = l:cmd . "tabnew " . expand("<cfile>") . " \<Bar> "
  "     let l:linecnt = l:linecnt + 1
  " endwhile
  execute l:cmd
endfunction
command! -range=% OpenFileOnEachLine <line1>,<line2>call OpenFileOnEachLine()

" Open multiple files each in its own tab
" @... [path[]] Filepath to open. Wildcard is accepted.
function! TabnewMulti(...)
  let l:files = []
  for l:paths in a:000
    for l:node in glob(l:paths, 0, 1)
      " Get absolute path or it fails when the arguments contains
      " recursive wildcard and the expanded result contains files in
      " subdirectory as autocmd changes pwd to the file's containing
      " dirctory and relative path breaks.
      " Also exclude directories.
      if filereadable(l:node)
        call add(l:files, fnamemodify(l:node, ':p'))
      endif
    endfor
  endfor
  let l:filenum = len(l:files)
  if l:filenum == 0
    echohl WarningMsg | echo 'No matching file' | echohl NONE
    return
  endif
  let l:orgtabnr = tabpagenr()
  for l:file in l:files
    execute 'tabnew '.l:file
  endfor
  execute l:orgtabnr.'tabnext'
  " FIXME this message is not displayed
  echo printf('%s file%s opened', l:filenum, l:filenum > 1 ? 's' : '')
endfunction
command! -complete=file -nargs=+ TabnewMulti call TabnewMulti(<f-args>)

function! OutputEditorCmdToPreview(cmd) abort
  let l:org_reg_contents = @@
  redir @">
  try
    silent execute a:cmd
  catch
    echohl ErrorMsg | echo v:exception | echohl NONE
    let @@ = l:org_reg_contents
    return
  finally
    redir END
  endtry

  execute printf('pedit +file\ [%s] %s', escape(a:cmd, ' \'), tempname())
  wincmd P
  %delete _
  put "
  0delete _
  set nomodified

  let @@ = l:org_reg_contents
endfunction
command! -complete=command -nargs=+ OutputEditorCmdToPreview call OutputEditorCmdToPreview(<q-args>)

function! SetOperatorFunc(funcname)
  execute 'set operatorfunc=' . a:funcname
  echohl Identifier | echon a:funcname | echohl NONE
  echon ' is being called. Enter motion key:'
endfunction

function! GetOperatorText(operatortype, noline)
  if a:operatortype ==# 'v'
    normal! `<v`>y
  elseif a:operatortype ==# 'char'
    normal! `[v`]y
  else
    if a:noline
      echohl WarningMsg
      echo "line-wise motion and line/block-wise selection is not supported"
      echohl NONE
      throw "Exception"
    endif

    normal! `[V`]y
  endif
  return @"
endfunction

function! GetVisualText()
  normal! gvy
  let l:result = getreg('"')
  normal! gv
  return l:result
endfunction

" Get ftplugins (including after) for the specified file type and return them as a list
function! GetFtplugins(filetype)
  let l:files = []
  let l:basedir = expand('~/toybox/vim/rtp/')
  let l:trailing_path = 'ftplugin/' . a:filetype . '.vim'
  let l:ftppath = l:basedir . l:trailing_path
  let l:aftppath = l:basedir . 'after/' . l:trailing_path

  if filereadable(l:ftppath)
    call add(l:files, l:ftppath)
  endif
  if filereadable(l:aftppath)
    call add(l:files, l:aftppath)
  endif

  return l:files
endfunction

" Open ftplugin (including after) for the specified file type
function! OpenFtplugins(...)
  let l:files = []
  for l:ft in a:000
    let l:files += GetFtplugins(l:ft)
  endfor

  if empty(l:files)
    redraw
    echo 'No ftplugins found'
    return
  endif

  for l:file in l:files
    silent execute 'tabnew '.l:file
  endfor
endfunction
command! -nargs=+ -complete=filetype OpenFtplugins :call OpenFtplugins(<f-args>)

" Set filetype again with the current buffer's file type
function! SetFt(...)
  execute 'set filetype=' . get(a:000, 0, &filetype)
endfunction
command! -nargs=? -complete=filetype SetFt :call SetFt(<f-args>)
cnoreabbrev sf SetFt

" 'lmake' without moving to location list window
function! MyMake(...) abort
  let l:cmd = 'silent lmake! '.join(a:000)
  echohl Identifier | echo 'Making... ' | echohl NONE
  execute l:cmd
  let l:errorexists = qf#base#QFOpenSmart(g:qf#base#qf_mode_location, v:false, 0)
  " On linux console, bash console will be shown when making and vim is
  " brought back when make is done. This causes the contents of the file now
  " shown properly. 'redraw!' to fix it.
  if !(has('gui') || has('nvim'))
    redraw!
  endif
  if l:errorexists
    echohl WarningMsg | echon 'Failed :(' | echohl NONE
  else
    echohl Identifier | echon 'Done!' | echohl NONE
  endif
endfunction
command! -nargs=* MyMake :call MyMake(<f-args>)

" Solution for restoring window height inside <expr> keymap
" (<expr> does not allow `windo`)
function! SaveWinheight() abort
  let l:winheights = {}
  for i in range(1, winnr('$'))
    let l:winheights[win_getid(i)] = winheight(0)
  endfor

  function! l:winheights.restore() abort
    for i in range(1, winnr('$'))
      execute "resize " . self[win_getid(i)]
    endfor
  endfunction

  return l:winheights
endfunction

" Display dictionary in accending order
function! DispOptions(title, option, message, ...) abort
  let l:SortFunc = get(a:000, 0, '')
  let l:key_name = get(a:000, 1, '')

  echohl Statement | echo a:title | echohl NONE
  for [k,v] in sort(items(a:option), l:SortFunc)
    echo printf('  %s: %s', k, (type(v) == v:t_dict ? v[l:key_name] : v))
  endfor
  unlet k v
  echohl Function | echo a:message | echohl NONE
endf

" Display dictionary in accending order in oneline
function! DispOptionsOneLine(title, option, ...) abort
  let l:SortFunc = get(a:000, 0, '')
  let l:key_name = get(a:000, 1, '')

  echohl Function | echo printf('-- %s -> %s: ', a:title, DictToOneLineString(a:option, ', ', l:SortFunc, l:key_name)) | echohl NONE
endf

function! DictToOneLineString(dict, ...) abort
  let l:separator = get(a:000, 0, ', ')
  let l:SortFunc = get(a:000, 1, '')
  let l:key_name = get(a:000, 2, '')

  let l:output = []
  for [k,v] in sort(items(a:dict), l:SortFunc)
    call add(l:output, printf('%s[%s]', (type(v) == v:t_dict ? v[l:key_name] : v), k))
  endfor
  return join(l:output, l:separator)
endfunction

" Function for sort() to sort 2D list based on the first element of inner array.
" Main usage is to sort list returned by items({dict}).
" Default algorithm of sort() has case insensitive sorting, but it does not
" guarantee that either UPPERCASE or lowercase precedes the other.
" This sort place lowercase before UPPERCASE within the same letter.
function! SortItemsCaseIns(one, two)
  let [l:key1, l:key2] = [a:one[0], a:two[0]]
  if l:key1 ==# l:key2
    return 1
  endif
  if l:key1 ==? l:key2
    " same char but different case -> lowercase should precedes UPPERCASE
    return char2nr(l:key1) > char2nr(l:key2) ? -1 : 1
  endif
  return l:key1 > l:key2 ? 1 : -1
endfunction

" Function for sort() to sort 2D list based on the second element of inner array.
" Main usage is to sort list returned by items({dict}).
" This essentially sort dict by value.
function! SortItemsByValue(one, two)
  return a:one[1] > a:two[1] ? 1 : -1
endfunction

" Like SortItemsByValue() but use nested value
function! SortItemsByNestedValue(key, one, two)
  return a:one[1][a:key] > a:two[1][a:key] ? 1 : -1
endfunction

function! s:diff(...)
  if a:0 != 2
    echoerr 'Diff takes exactly 2 arguments'
    return
  endif

  let l:msgFileNotExists = '%s does not exist'
  if !filereadable(a:1)
    echoerr printf(l:msgFileNotExists, a:1)
    return
  endif
  if !filereadable(a:2)
    echoerr printf(l:msgFileNotExists, a:2)
    return
  endif

  let l:fullpath1 = fnamemodify(a:1, ';p')
  let l:fullpath2 = fnamemodify(a:2, ';p')
  execute 'tabnew '.l:fullpath1
  execute 'diffsplit '.l:fullpath2
endfunction
command! -complete=file -nargs=+ Diff :call s:diff(<f-args>)

function! IsRegMultiline(reg)
  let l:reg_content = getreg(a:reg)
  return match(l:reg_content, '\r\|\n') >= 0
endfunction

" Capture the result of find & grep in quickfix window
function! CaptureFindGrep(cmd) abort
  let l:results = systemlist(a:cmd)
  if v:shell_error
    redraw
    echohl WarningMsg | echo join(l:results) | echohl NONE
    return
  endif
  if empty(l:results)
    redraw
    echo 'No match found'
    return
  endif

  let l:qflists = []
  call setqflist([], ' ', {'lines': l:results,'title': a:cmd})
  call qf#base#QFOpenSmart(g:qf#base#qf_mode_quickfix, v:false, 0)
endfunction
command! -complete=file -nargs=1 CaptureFindGrep call CaptureFindGrep(<q-args>)
cnoreabbrev fig CaptureFindGrep find -type f -exec grep -Hn {} \\;<C-Left><C-Left><Left>

function! InstallPluginManager()
  if !executable('git')
    echo 'Install `git` first'
    return
  endif

  !git clone https://github.com/junegunn/vim-plug.git ~/.vim/bundle/vim-plug
endfunction

function! RunInNewTabTerminal(shellCmd, focus) abort
  let l:vimCmd = 'tab split term://' . a:shellCmd
  if a:focus
    let l:vimCmd .= ' | startinsert'
  endif
  execute l:vimCmd
endfunction
command! -complete=shellcmd -nargs=+ -bang RunInNewTabTerminal call RunInNewTabTerminal(<q-args>, <bang>0)

function! DeleteHiddenBuffers()
  let tpbl = []
  call map(range(1, tabpagenr('$')), 'extend(tpbl, tabpagebuflist(v:val))')

  let l:hidden_bufs = filter(range(1, bufnr('$')), 'bufexists(v:val) && index(tpbl, v:val) == -1')

  for l:hidden_buf in l:hidden_bufs
    silent execute 'bwipeout' l:hidden_buf
  endfor
endfunction
command! DeleteHiddenBuffers call DeleteHiddenBuffers()
" --- || functions || }}}
